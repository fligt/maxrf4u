[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to maxrf4u",
    "section": "",
    "text": "Macro X-Ray Fluorescence (MA-XRF) scanning of cultural heritage objects is becoming a standard technique that is increasingly applied also to paper based artworks. Unfortunately, the visualization and interpretation of MA-XRF data is technically challenging and therefore obstructing interdisciplinary cooperation. That is why I have started to develop the open source python package maxrf4u to help you and me with our data analysis.\nThis package is developed out in the open. If you are interested you can follow my ideas under construction in this documentation and already try out the Jupyter notebooks in this repository. Although this is a-work-in-progress, the package is available for installation from the python package index:\n\nFrank Ligterink\nSee link to documentation.",
    "crumbs": [
      "Welcome to maxrf4u"
    ]
  },
  {
    "objectID": "peak-pattern-puzzle.html",
    "href": "peak-pattern-puzzle.html",
    "title": "The peak pattern puzzle",
    "section": "",
    "text": "We now arrive at the central problem of MA-XRF analysis. Given a spectrum with some peaks, and given the theoretical emission peak patterns for different chemical elements, which chemical elements are present in the sample? This is what I call the peak pattern puzzle.\nIt is important to note that not all peaks are always due to the actual fluorescence emission of chemical elements present in the scanned object. Other peaks are generated by the instrument itself. And small peaks can also just be noise. Instrument peaks are common to all spectra. For example, the large peak observed in all spectra near zero energy is a result of the instrument detector physics. Other peaks above 18 keV are due emission and subsequent scattering of the rhodium anode present in the x-ray tube.\nTo simplify our current analysis let’s exclude the light elements and rare elements that we do not expect to detect in drawings. You can inspect the Elements Of Interest by importing EOI. Elements are excluded from the selection with the # sign in front of the chemical symbol. If needed you can add or remove elements by adding or removing the hash sign #.\nfrom maxrf4u import EOI\nEOI = ['#H', '#He', '#Li', '#Be', '#B', '#C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', \n       '#Ar', 'K', 'Ca', '#Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', '#Ga', '#Ge', 'As', \n       '#Se', 'Br', '#Kr', '#Rb', 'Sr', '#Y', '#Zr', '#Nb', '#Mo', '#Tc', '#Ru', 'Rh', '#Pd', 'Ag', 'Cd', \n       '#In', 'Sn', '#Sb', '#Te', 'I', '#Xe', '#Cs', 'Ba', '#La', '#Hf', '#Ta', '#W', '#Re', '#Os', '#Ir', \n       '#Pt', 'Au', 'Hg', '#Tl', 'Pb', '#Bi', '#Po', '#At', '#Rn', '#Fr', '#Ra', '#Ac', '#Rf', '#Db', '#Sg', \n       '#Bh', '#Hs', '#Mt', '#Ds', '#Rg', '#Cn', '#Nh', '#Fl', '#Mc', '#Lv', '#Ts', '#Og']\nNow to start analyzing our peak pattern puzzle you first need to import and instantiate the Peak_Pattern_Atlas() class. You need to provide the datastack_file= option to include the instrument pattern in the atlas. Much should be said about the excitation energy tube_keV. However I can not elaborate on this topic now.\nfrom maxrf4u import Peak_Pattern_Atlas\nppa = Peak_Pattern_Atlas(elements_of_interest=EOI, datastack_file='RP-T-1898-A-3689.datastack', tube_keV=30)\n\nPlease wait while initializing peak pattern atlas...\nTo activate interactive plotting you need to execute the notebook magic command:\nIf it turns out that during your analysis you need to adjust your list of elements of interest you can include or exclude elements with the Peak_Pattern_Atlas.update() method.\nppa.update_eoi(['Zr', 'Ar'])\nppa.plot_patterns()\nIn the previous section, out of one million spectra, we have cherry picked 22 hotmax spectra and within each spectrum detected potentially significant peaks exceeding the Poisson noise level. We can now proceed to solve the peak pattern puzzle for each hotmax spectrum. In other words, for each spectrum explain the presence of each significant (numbered) peak. Can we attribute a given peak to a specific chemical element, the instrument or noise?\nIn other words, we can start to ‘explain away’ all peaks. It is highly instructive to walk through some interesting hotmax spectra and see which element patterns explain the peak patterns that we observe. To do so you can use the Peak_Pattern_Atlas.plot_puzzle() method with the select_elems= keyword argument.",
    "crumbs": [
      "The peak pattern puzzle"
    ]
  },
  {
    "objectID": "peak-pattern-puzzle.html#exploring-the-peak-pattern-puzzle-for-each-hotmax-spectrum",
    "href": "peak-pattern-puzzle.html#exploring-the-peak-pattern-puzzle-for-each-hotmax-spectrum",
    "title": "The peak pattern puzzle",
    "section": "Exploring the peak pattern puzzle for each hotmax spectrum",
    "text": "Exploring the peak pattern puzzle for each hotmax spectrum\n\nppa.plot_puzzle(0, select_elems=['Ca'])\n\n\n\n\n\n\n\n\nIn the puzzle plot for hotmax spectrum #0 above, beside instrument peaks, all other peaks are rather small. I would say that only sub peak (4) can be explained as the \\(K_{\\alpha}\\) emission of calcium.\n\nppa.plot_puzzle(1, select_elems=['O', 'Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(2, select_elems=['Pb', 'Fe'])\n\n\n\n\n\n\n\n\nIn hotmax spectrum #2 above, one can see that sub peaks (0), (1), (3) and (6) can all be explained by the emission of lead (Pb). The tiny peaks (8) and (9) are explained by respectively iron (Fe) and calcium (Ca).\n\nppa.plot_puzzle(3, select_elems=['Ca', 'Fe', 'Cl', 'Zn'])\n\n\n\n\n\n\n\n\nIn hotmax spectrum #3 sub peak (3) interestingly indicates the presence of chlorine (Cl). Furthermore we find evidence for calcium (Ca), iron (Fe), and perhaps zinc (Zn).\n\nppa.plot_puzzle(4, select_elems=['Ca', 'K', 'S'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(5, select_elems=['Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(6, select_elems=['Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(7, select_elems=['Ca', 'Ti', 'Fe'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(8, select_elems=['Ti', 'Ba', 'Fe'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(9, select_elems=['Mn', 'Fe', 'Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(10, select_elems=['Fe', 'Ca'])\n\n\n\n\n\n\n\n\nThe tiny peak (6) in hotmax spectrum #10 is clearly the escape peak for Fe located at 6.40 keV minus 1.74 keV.\n\nppa.plot_puzzle(11, select_elems=['Fe', 'Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(12, select_elems=['Cu', 'Zn', 'Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(13, select_elems=['Pb'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(14, select_elems=['Pb', 'Fe', 'Ca'])\n\n\n\n\n\n\n\n\n\nplt.close('all')\n\n\nppa.plot_puzzle(15, select_elems=[])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(16, select_elems=['Pb'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(17, select_elems=[])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(18, select_elems=['Pb', 'Fe'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(19, select_elems=['Ca', 'Zn'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(20, select_elems=['Ca'])\n\n\n\n\n\n\n\n\n\nppa.plot_puzzle(21, select_elems=['Ca', 'Cl'])\n\n\n\n\n\n\n\n\n\nppa.contains_dict\n\n{5: ['Ca'],\n 0: ['Ca'],\n 1: ['O', 'Ca'],\n 2: ['Pb', 'Fe'],\n 3: ['Ca', 'Fe', 'Cl', 'Zn'],\n 4: ['Ca', 'K', 'S'],\n 6: ['Ca'],\n 7: ['Ca', 'Ti', 'Fe'],\n 8: ['Ti', 'Ba', 'Fe'],\n 9: ['Mn', 'Fe', 'Ca'],\n 10: ['Fe', 'Ca'],\n 11: ['Fe', 'Ca'],\n 12: ['Cu', 'Zn', 'Ca'],\n 13: ['Pb'],\n 14: ['Pb', 'Fe', 'Ca'],\n 15: [],\n 16: ['Pb'],\n 17: [],\n 18: ['Pb', 'Fe'],\n 19: ['Ca', 'Zn'],\n 20: ['Ca'],\n 21: ['Ca', 'Cl'],\n 22: None}\n\n\nOk, that is it. Let’s summarize which chemical elements we found in our MA-XRF data cube.",
    "crumbs": [
      "The peak pattern puzzle"
    ]
  },
  {
    "objectID": "peak-pattern-puzzle.html#summary",
    "href": "peak-pattern-puzzle.html#summary",
    "title": "The peak pattern puzzle",
    "section": "Summary",
    "text": "Summary\n\n\nCode\nimport matplotlib.pyplot as plt \nfrom maxrf4u import DataStack\n\n\n\n\nCode\nds = DataStack('RP-T-1898-A-3689.datastack')\n\nx_keVs = ds.read('maxrf_energies') \ny_max = ds.read('maxrf_maxspectrum')\n\n\n\nfound_elems = ['S', 'Ca', 'K', 'Cl', 'Fe', 'Mn', 'Cu', 'Zn', 'Pb', 'Ti', 'Ba']\nppa.plot_patterns(select_elems=found_elems)\n\n\n\n\n\n\n\n\nAltogether the spectral data indicates that 11 chemical elements are present in the Susanna drawing: sulfur (S), chlorine (Cl), potassium (K), calcium (Ca), barium (Ba), titanium (Ti), manganese (Mn), iron (Fe), copper (Cu), zinc (Zn) and lead (Pb).\nIn the next section we will look into the spatial distribution of these elements…",
    "crumbs": [
      "The peak pattern puzzle"
    ]
  },
  {
    "objectID": "peak-pattern-puzzle.html#functions",
    "href": "peak-pattern-puzzle.html#functions",
    "title": "The peak pattern puzzle",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\natomnums_from_elems\n\n atomnums_from_elems (elements)\n\n*Convenience function to convert list of elements into atomic numbers.\nNeeded because zarr format 3 can not handle strings (yet).\nReturns: atomnums*\n\nsource\n\n\nelems_from_atomnums\n\n elems_from_atomnums (atomnum_list)\n\n*Convenience function to convert integer list atomnum_list into chemical symbols.\nNeeded because zarr format 3 can not handle strings (yet).\nReturns: elements*\n\nsource\n\n\nupdate_eoi\n\n update_eoi (elements_of_interest, add_elems)\n\n*Update elements_of_interest list for elements list add_elems.\nFor example: add_elems=[‘#Al’, ’Ga]*\n\nsource\n\n\nget_instrument_pattern\n\n get_instrument_pattern (datastack_file)\n\n*Generate instrument peak pattern.\nPattern dictionary contains strongest Rhodium anode emission peaks,\ntheir corresponding Compton shifted peaks, and a sensor peak\nReturns: instrument_pattern_dict*\n\nsource\n\n\ncolorize\n\n colorize (elem)\n\nPick fixed color from nice color map for elements of interest.\n\nsource\n\n\nget_eoi_patterns\n\n get_eoi_patterns (elements_of_interest, tube_keV=40)\n\n*Create a list of xrf spectrum pattern dictionaries for all elements_of_interest.\nHashed (#) elements are excluded from the list.\nReturns eoi_ptrns dictionary list.*\n\nsource\n\n\nplot_patterns\n\n plot_patterns (eoi_ptrns, select_elems=None, instrum_ptrn=None, ax=None)\n\n*Wrapper function to plot overview of element patterns elem_ptrns and instrument patterns in axes ax.\nReturns: ax*\n\nsource\n\n\nPeak_Pattern_Atlas\n\n Peak_Pattern_Atlas (elements_of_interest=None, tube_keV=40,\n                     datastack_file=None, verbose=True)\n\nCompute atlas of peak patterns for all elements_of_interest.",
    "crumbs": [
      "The peak pattern puzzle"
    ]
  },
  {
    "objectID": "spatial-verus-spectral.html",
    "href": "spatial-verus-spectral.html",
    "title": "Spatial versus spectral",
    "section": "",
    "text": "In the previous sections we have converted and calibrated the original .raw spectral image data file into an analysis ready .datastack file. We will now gently start to learn how this three dimensional data cube is structured. Basically there are two ways to look at this data. One perspective is to think of the data cube as a stack of gray scale images. Every image has a different energy associated with it. If you remember from the previous section, these energies are the X-ray photon energies, expressed in kilo electron Volts (keV). Each image in the stack contains a distribution of intensities (photon counts). This is the lasagna view.\nAnother way to think of the same data cube is to describe it as a rectangular bundle of spectra. At each spatial (x,y) location the data cube contains a spectrum with varying intensity along the third dimension (z) of the cube. This is the spaghetti view. We will come back to this in the next section.\nVery roughly speaking, the spatial intensity distribution within a slice located at a specific peak energy band represents the spatial distribution of a certain chemical element. For a start we can take a look at the largest peak in the max spectrum. This peak in the energy range of 6.1-6.7 keV is caused by the presence of the chemical element iron in the drawing. Because it is the largest peak, is is called the Fe_Ka (alpha) peak. Without prior knowledge of XRF physics (we will get to this topic later on) we can compute peak slice map for this energy band.\nTo do so, we need to read the required datasets with the DataStack.read(&lt;datapath&gt;) method.\nfrom maxrf4u import DataStack\nds = DataStack('RP-T-1898-A-3689.datastack') \n\nx_keVs = ds.read('maxrf_energies')\ny_max = ds.read('maxrf_maxspectrum') \ncube = ds.read('maxrf_cube', compute=False) # don't load into memory yet (too big)\n\nis_iron_Ka_band = (x_keVs &gt; 6.1) * (x_keVs &lt; 6.7)\nWe can now compute the iron distribution image by averaging over intensity at each pixel in the 60 images in the Fe_Ka energy band and plot the image.\nFeKa_slice = cube[:,:,is_iron_Ka_band].compute() # load only this slice into memory (takes 21 seconds)\nFeKa_map = FeKa_slice.sum(axis=2) / 60 # average over number of channels in the Fe_Ka band\nimport matplotlib.pyplot as plt\nfig, [ax, ax1] = plt.subplots(ncols=2, sharex=True, sharey=True, figsize=[8, 5])\n\nax.imshow(FeKa_map);\nax.set_title('Fe_Ka map (unclipped)');\nax1.imshow(FeKa_map, vmax=2);\nax1.set_title('Fe_Ka map (clipped intensity)');\nOn the right we see here the distribution of iron associated with the iron-gall ink that Rembrandt used, as well as bright yellow speckles caused by iron particles present in the paper background. In order to make this visible, I had to clip the image intensity. On the left we see the very same image without clipping. Due to the high intensity of the iron speckles the contrast of the ink is very low.",
    "crumbs": [
      "Spatial versus spectral"
    ]
  },
  {
    "objectID": "spatial-verus-spectral.html#image-registration-helper",
    "href": "spatial-verus-spectral.html#image-registration-helper",
    "title": "Spatial versus spectral",
    "section": "Image registration helper",
    "text": "Image registration helper\nNow, let’s compare the iron distribution map with a photo of the drawing. In order to make such a comparison we need to register the two images. Fully automated registration of images is a very important capability that is unfortunately out of scope here. Instead I have created a four point warping function warp() that will do the job if we provide the corresponding corner points of both the source and destination image. These corner points can be be generated using the interactive ImageRegistrationHelper() function as shown below. This function displays interactive map widgets with markers that need to be positioned manually to corresponding landmarks on both the source (left) and destination (right) image. in our situation it is preferred to warp the visible image onto the iron map.\n\n\nCode\nsusanna_highres_file = 'RP-T-1898-A-3689_highres.png'\nsusanna_highres = plt.imread(susanna_highres_file)\n\nsrc_im = susanna_highres\ndst_im = np.clip(FeKa_map, a_min=0, a_max=2)\n\n\n\nfrom maxrf4u import ImageRegistrationHelper\n\n\nimreg = ImageRegistrationHelper(src_im, dst_im)\nimreg.show()\n\n\nTo register both images you first need to drag all eight markers to pairwise corresponding locations. When positioned correctly you can print the actual positions of the markers with the .get_marker_coordinates() method.\n\nsrc_points, dst_points = imreg.get_marker_coordinates();\n\nsrc_points = [[78.5, 204.6], [4340.1, 180.4], [4376.99, 4724.0], [110.1, 4766.3]]\ndst_points = [[24.7, 7.64], [1579.0, 10.2], [1563.8, 1666.0], [8.22, 1671.92]]\n\n\nGiven the corresponding source and destination marker points, the source image can be warped (registered) onto the destination image using the warp() function.\n\n\nCode\nsusanna_highres_file = 'RP-T-1898-A-3689_highres.png'\nsusanna_highres = plt.imread(susanna_highres_file)\n\nsrc_im = susanna_highres\ndst_im = FeKa_map \n\n# corner points for image registration \nsrc_points = np.array([[78.5, 204.6], [4340.1, 180.4], [4376.99, 4724.0], [110.1, 4766.3]])\ndst_points = np.array([[24.7, 7.64], [1579.0, 10.2], [1563.8, 1666.0], [8.22, 1671.92]])\n\n\n\nfrom maxrf4u import warp\n\n\nimvis_reg_highres, extent = warp(src_im, dst_im, src_points, dst_points, rgba=False)\nimvis_reg, extent = warp(src_im, dst_im, src_points, dst_points, keep_scale=False, rgba=False)\n\nFor future calculations we will store the registered images and their extent in our .datastack file, using the append() function. In our further analysis we can simply use the registered images with the DataStack.read() method.\n\nfrom maxrf4u import append\n\n\nappend(imvis_reg, 'imvis_reg', 'RP-T-1898-A-3689.datastack')\nappend(imvis_reg_highres, 'imvis_reg_highres', 'RP-T-1898-A-3689.datastack')\nappend(extent, 'imvis_extent', 'RP-T-1898-A-3689.datastack')\n\n\n\nCode\nds = DataStack('RP-T-1898-A-3689.datastack')\n\nextent = ds.read('imvis_extent')\nimvis_reg_highres = ds.read('imvis_reg_highres')\n\nfig, [ax1, ax2] = plt.subplots(ncols=2, figsize=[7, 4], sharex=True, sharey=True)\n\nax1.imshow(FeKa_map, vmax=2)\nax2.imshow(imvis_reg_highres, extent=extent);\nax1.set_xlim([150, 340])\nax1.set_ylim([800, 500])\n\n\n\n\n\n\n\n\n\nNicely registered!",
    "crumbs": [
      "Spatial versus spectral"
    ]
  },
  {
    "objectID": "spatial-verus-spectral.html#functions",
    "href": "spatial-verus-spectral.html#functions",
    "title": "Spatial versus spectral",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nimreg_to_datastack\n\n imreg_to_datastack (src_im, dst_im, datastack_file)\n\n*Register source image src_src onto destination image dst_im\nand append imvis_reg_highres, imvis_reg and imvis_extent to datastack_file.\nReturns: imvis_reg, imvis_reg_highres, extent*\n\nsource\n\n\nimreg\n\n imreg (src_im, dst_im, keep_scale=False)\n\n*Use SIFT-RANSAC algorithm to register source image im_src onto a destination image dst_im.\nReturns:*\n\nsource\n\n\nlatlon_to_xy\n\n latlon_to_xy (imshape, locations)\n\n*Flip and exchange list with latitude-longitude locations into list of xy_points.\nReturns: xy_points*\n\nsource\n\n\nxy_to_latlon\n\n xy_to_latlon (imshape, xy_points=None)\n\n*Flip and exchange list with xy points into list of latitude-longitude locations.\nIf xy_points are not specified, locations of the four image corner are returned.\nReturns: locations*\n\nsource\n\n\nwarp\n\n warp (im_src, im_dst, pts_src, pts_dst, keep_scale=True, rgba=True,\n       alpha_color=[1, 0, 0])\n\n*Opencv based homographic registration. Can return transparent overlay (rgba).\nReturns: im_warped, *extent**\n\nsource\n\n\nImageRegistrationHelper\n\n ImageRegistrationHelper (src_im, dst_im, src_points=None,\n                          dst_points=None, scale_down=True)\n\nCreate interactive image registration.",
    "crumbs": [
      "Spatial versus spectral"
    ]
  },
  {
    "objectID": "xphysics.html",
    "href": "xphysics.html",
    "title": "XRF physics - the gory details",
    "section": "",
    "text": "If you are not into physics, you can safely skip this section.\nIn a previous section of this documentation I described how one can use the xrf_spectrum() function to simulate an X-ray fluorescence spectrum for a given chemical element. The whole point of the maxrf4u package is to enable you to do so but to protect you from the gory details of XRF physics. However, in case you are interested to learn how this computation is done you can find the details of that calculation here.\nThe modeling of X-ray fluorescence spectra fundamental parameters is described in a nice tutorial Basic Fundamental Parameters in X-Ray Fluorescence by Volker Thomsen available online.\nThe fundamental parameters are measured x-ray properties of chemical elements that we need to look up somehow. Not so very long ago physicist would look up the x-ray fluorescence energies and other measured properties of different chemical elements in the X-RAY DATA BOOKLET. Instead, more conveniently I will show how to look up those values programmatically using the well documented python package. See pypi and github. One can also consult these values in the XRayDB interactive web app.\nSo, let’s see how we can implement some of the equations in the tutorial by Volker Thomsen and look up the required parameter values using xraydb…",
    "crumbs": [
      "XRF physics - the gory details"
    ]
  },
  {
    "objectID": "xphysics.html#pure-iron",
    "href": "xphysics.html#pure-iron",
    "title": "XRF physics - the gory details",
    "section": "Pure iron",
    "text": "Pure iron\nLet’s check if we can reproduce the numerical example for the intensity of the iron \\(K_{\\alpha}\\) emission intensity of a thick pure iron irradiated by a cadmium isotope emitting at 22.1 keV. Here is the approximate equation describing the intensity of the \\(K_{\\alpha}\\) peak for a thick sample of iron. The emission intensity quickly approaches a maximum due to the limited penetration of the radiation into the sample:\n\\[ I_i = (I_0 C_i J_K g_{Ka} \\omega_K)(\\Omega/4 \\pi)\\frac{\\mu_i}{\\mu_s + \\mu_{s,Ei}} \\tag{Thomsen eq. 12}\\]\nLet’s try to extract numerical values for the transition probability \\(g_{K \\alpha}\\), the jump ratio coefficient \\(J_K\\), the fluorescence yield \\(\\omega_K\\) and the mass absorption coefficients at the at the incoming energy \\(\\mu_{i}\\) and emission energy \\(\\mu_{s,Ei}\\) from xraydb.\n\\[g_{K \\alpha} = 0.882\\]\n\\[J_K = 0.877\\]\n\\[\\omega_K = 0.347\\]\n\\[\\mu_i = \\mu_s = 18.55 cm^2/g \\tag{at 22.1 keV}\\]\n\\[\\mu_{s,Ei} = 70.46 cm^2/g \\tag{at 6.4 keV} \\]\n\nTransition probability \\(g_{K_{\\alpha}}\\)\nLet’s take a look at to transition probability $ g_{K }$. This the probability that \\(K_{\\alpha}\\) radiation will be emitted rather than that of another K line which is given by:\n\\[ g_{K\\alpha} = \\frac{I(K_{\\alpha})}{I(K_{\\alpha}) + I(K_{\\beta}) +...} \\tag{Thomsen eq. 6} \\]\nStarting point for all calculations is an overview of emission lines for the element of interest these can be accessed using the function xray_lines().\n\nimport xraydb\n\n\nxraydb.xray_lines('Fe')\n\n{'Ka3': XrayLine(energy=6267.4, intensity=0.000276096, initial_level='K', final_level='L1'),\n 'Ka2': XrayLine(energy=6392.1, intensity=0.294023, initial_level='K', final_level='L2'),\n 'Ka1': XrayLine(energy=6405.2, intensity=0.580277, initial_level='K', final_level='L3'),\n 'Kb3': XrayLine(energy=7059.3, intensity=0.0425566, initial_level='K', final_level='M2'),\n 'Kb1': XrayLine(energy=7059.3, intensity=0.0821556, initial_level='K', final_level='M3'),\n 'Kb5': XrayLine(energy=7110.0, intensity=0.000712115, initial_level='K', final_level='M4,5'),\n 'Lb4': XrayLine(energy=791.9, intensity=0.413833, initial_level='L1', final_level='M2'),\n 'Lb3': XrayLine(energy=791.9, intensity=0.586166, initial_level='L1', final_level='M3'),\n 'Ln': XrayLine(energy=628.6, intensity=0.0742626, initial_level='L2', final_level='M1'),\n 'Lb1': XrayLine(energy=717.9, intensity=0.925737, initial_level='L2', final_level='M4'),\n 'Ll': XrayLine(energy=615.5, intensity=0.0990365, initial_level='L3', final_level='M1'),\n 'La2': XrayLine(energy=704.8, intensity=0.0892847, initial_level='L3', final_level='M4'),\n 'La1': XrayLine(energy=704.8, intensity=0.811679, initial_level='L3', final_level='M5')}\n\n\nThe names of these lines are denoted in Siegbahn notation (e.g. Ka3, where ‘a’ stands for alpha). The lines are grouped according to their initial level, denoted with the IUPAC notation e.g. ‘K’ or ‘L1’. Within these groups the intensities a.k.a. transition probabilities are normalized to unity. The intensity of the \\(K_{\\alpha}\\) line is actually a sum of multiple overlapping Ka lines.\nTo the xray_lines() function one could provide an additional argument of an excitation_energy (in units of electron Volts [eV]) . This simply crops the list to emission lines below the corresponding edge, like so:\n\nxraydb.xray_lines('Fe', excitation_energy=7111) # just below the K edge at 7112\n\n{'Lb4': XrayLine(energy=791.9, intensity=0.413833, initial_level='L1', final_level='M2'),\n 'Lb3': XrayLine(energy=791.9, intensity=0.586166, initial_level='L1', final_level='M3'),\n 'Ln': XrayLine(energy=628.6, intensity=0.0742626, initial_level='L2', final_level='M1'),\n 'Lb1': XrayLine(energy=717.9, intensity=0.925737, initial_level='L2', final_level='M4'),\n 'Ll': XrayLine(energy=615.5, intensity=0.0990365, initial_level='L3', final_level='M1'),\n 'La2': XrayLine(energy=704.8, intensity=0.0892847, initial_level='L3', final_level='M4'),\n 'La1': XrayLine(energy=704.8, intensity=0.811679, initial_level='L3', final_level='M5')}\n\n\nLet’s see if the iron \\(K\\) intensities sum up to unity.\n\nFe_lines = xraydb.xray_lines('Fe') \nFe_names = list(Fe_lines.keys())\nFeK_names = [name for name in Fe_names if name.startswith('K')]\nFeKa_names = [name for name in Fe_names if name.startswith('Ka')]\nFeKb_names = [name for name in Fe_names if name.startswith('Kb')]\n\nFeK_total = sum([Fe_lines[l].intensity for l in FeK_names])\nFeKa_intensity = sum([Fe_lines[l].intensity for l in FeKa_names])\nFeKb_intensity = sum([Fe_lines[l].intensity for l in FeKb_names])\n\nprint(Fe_names)\nprint(FeKa_names)\nprint(FeKa_names) \n\nprint(f'Fe_Ka intensity: {FeKa_intensity:.04f}, Fe_Ka intensity: {FeKb_intensity:.04f}')     \nprint(f'Fe_K total: {FeK_total:.04f}')\n\n['Ka3', 'Ka2', 'Ka1', 'Kb3', 'Kb1', 'Kb5', 'Lb4', 'Lb3', 'Ln', 'Lb1', 'Ll', 'La2', 'La1']\n['Ka3', 'Ka2', 'Ka1']\n['Ka3', 'Ka2', 'Ka1']\nFe_Ka intensity: 0.8746, Fe_Ka intensity: 0.1254\nFe_K total: 1.0000\n\n\nThe transition probability value reported by Thomsen \\(g_{K\\alpha} = 0.882\\) is actually one percent higher then our calculated value \\(0.8746\\). Perhaps this is due to to the varying energies within a line envelope.\n\n\nJump ratio coefficient \\(J_K\\)\nFor each line the initial level corresponds to a specific absorption edge (denoted with IUPAC notation e.g. ‘K’ or ‘L1’. An overview can be found using xray_edges().\n\nxraydb.xray_edges('Fe')\n\n{'K': XrayEdge(energy=7112.0, fyield=0.350985, jump_ratio=7.893),\n 'L1': XrayEdge(energy=844.6, fyield=0.001, jump_ratio=1.1289),\n 'L2': XrayEdge(energy=719.9, fyield=0.0036, jump_ratio=1.4),\n 'L3': XrayEdge(energy=706.8, fyield=0.0063, jump_ratio=3.099),\n 'M1': XrayEdge(energy=91.3, fyield=2.8e-06, jump_ratio=1.0),\n 'M2': XrayEdge(energy=52.7, fyield=1.6e-05, jump_ratio=1.0),\n 'M3': XrayEdge(energy=52.7, fyield=0.0, jump_ratio=1.0),\n 'M4': XrayEdge(energy=2.0, fyield=0.00219375, jump_ratio=1.0),\n 'M5': XrayEdge(energy=2.0, fyield=0.0, jump_ratio=1.0)}\n\n\nMore convenient, the properties of a specific element edge can be found using the function xray_edge().\n\nxraydb.xray_edge('Fe', 'K')\n\nXrayEdge(energy=7112.0, fyield=0.350985, jump_ratio=7.893)\n\n\nFrom the jump ratio \\(r_K\\) the jump ratio coefficient can be calculated using\n\\[ J_K = \\frac{r_K -1}{r_K} \\tag{Thomsen eq. 4}\\]\n\nr_K = xraydb.xray_edge('Fe', 'K').jump_ratio\nJ_K = (r_K - 1) / r_K\nprint(f'Jump ratio coefficient: {J_K:.03f}')\n\nJump ratio coefficient: 0.873\n\n\nOk, our computed value corresponds quite well with the value 0.877 reported by Thomsen.\n\n\nFluorescence yield \\(\\mathbf{\\omega_K}\\)\nThomsen writes: The last factor, the probability of \\(K\\) radiation rather than the production of an Auger electron, is called the fluorescence yield \\(\\omega_K\\). The dependence of the fluorescence yield for a specific edges \\(K\\) and \\(L\\) as a function of the atomic number is depicted in figure 4. Let’s reproduce these curves with xraydb.\nAs a first step, we need a list of chemical elements for increasing atomic number Z.\n\nZ_list = list(range(1, 92))\nelement_list = [xraydb.atomic_symbol(Z) for Z in Z_list]\nprint(element_list)\n\n['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa']\n\n\n\nZ_list_L = list(range(15, 92)) # Lighter elements do no have an L shell \nelement_list_L = [xraydb.atomic_symbol(Z) for Z in Z_list_L]\n\n\nfyield_K_list = [xraydb.xray_edge(e, 'K').fyield for e in element_list]\nfyield_L_list = [xraydb.xray_edge(e, 'L2').fyield for e in element_list_L]\n\n# for iron K the fluorescence yield is \nZ_Fe = 26 \nfyield_FeK = xraydb.xray_edge('Fe', 'K').fyield\n\n\nimport matplotlib.pyplot as plt\n\n\nfig, ax = plt.subplots(figsize=[8, 4]) \n\nax.plot(Z_list, fyield_K_list, label=r'K edge $\\omega_K$')\nax.plot(Z_list_L, fyield_L_list, label=r'L edge $\\omega_L$')\nax.scatter(Z_Fe, fyield_FeK, color='r')\nax.annotate(f'Fe ({fyield_FeK:.03f})', [Z_Fe+2, fyield_FeK])\nax.set_xlabel('Atomic number')\nax.set_ylabel('fluorescence yield')\nax.grid()\nax.legend();\n\n..\n\n\nOk, so we see that the computed fluorescence yield value 0.351 for the iron K edge \\(\\mathbf{\\omega_K}\\) corresponds to the reported value by thomsen 0.347 pretty well.\n\n\nCombining it all\nWe now have all ingredients to compute a theoretical (excitation) x-ray fluorescence spectrum with the function xrf_spectrum(). This function for each peak multiplies transition probability, jump ratio coefficient and fluorescence yield to obtain a theoretical excitation spectrum. Note that we do not yet take into account absorption effects or scattering effects. For comparison we plot this with the spectrum generated with my moseley package.\n\nfrom maxrf4u import get_element_spectrum \nimport moseley\n\n\nelement = 'Fe'\nexcitation_energy_keV = 21.1  \nx_keVs, y_spectrum = get_element_spectrum(element, excitation_energy_keV)\n\n\nfig, [ax0, ax1] = plt.subplots(nrows=2, figsize=[9, 6])\nax0.plot(x_keVs, y_spectrum)\nax0.set_title(f'XrayDB Theoretical XRF spectrum for {element}')\nax0.set_xlim([0, 22])\nax1.set_xlim([0, 22])\nax1.set_ylim([0, 1.3])\nax0.grid()\nax1.grid()\nax1.set_title('Same spectrum generated with moseley/fisx')\n\n# for comparison plot spectrum with fisx based moseley function \n\nxf = moseley.XFluo(element, tube_keV=excitation_energy_keV)\nxf.plot(ax=ax1, peak_labels='full', color='red')\nplt.tight_layout()\n\n..",
    "crumbs": [
      "XRF physics - the gory details"
    ]
  },
  {
    "objectID": "xphysics.html#functions",
    "href": "xphysics.html#functions",
    "title": "XRF physics - the gory details",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nget_element_spectra\n\n get_element_spectra (elements, x_keVs, excitation_energy_keV)\n\n*Compute theoretical emission spectrum for multiple elements.\nSorts elements according to largest (alpha) peak. Based on xraydb.\nReturns: elements, element_spectra*\n\nsource\n\n\nget_element_spectrum\n\n get_element_spectrum (element, excitation_energy_keV, normalize=True,\n                       x_keVs=None, std=0.01)\n\n*Compute simple excitation spectrum (no matrix effects).\nBased on xraydb.\nReturns: y_spectrum*\n\nsource\n\n\nElementLines\n\n ElementLines (element, excitation_energy_keV)\n\nComputes fluorescence emission line energies and intensities for element.\n\nsource\n\n\ngaussian_convolve\n\n gaussian_convolve (peak_energies, peak_intensities, x_keVs=None,\n                    std=0.01)\n\n*Convolves line spectrum defined by peak_energies and peak_intensities\nwith a Gaussian peak shape.*",
    "crumbs": [
      "XRF physics - the gory details"
    ]
  },
  {
    "objectID": "xphysics.html#absorption-and-scattering",
    "href": "xphysics.html#absorption-and-scattering",
    "title": "XRF physics - the gory details",
    "section": "Absorption and scattering",
    "text": "Absorption and scattering\nThe xraydb documentation gives an example calculation for different mass attenuation cross sections.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom xraydb import mu_elam\n\n\nenergy = np.arange(500, 25000, 10)  # energy in eV\nenergy_keV = energy / 1000 \n\n\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=[9, 7], sharex=True, sharey=True) \naxs = axs.flatten()\n\nelements = ['C', 'Ca', 'Fe', 'Pb']\n\nfor i, elem in enumerate(elements):       \n\n    mu_total = mu_elam(elem, energy, kind='total')\n    mu_photo = mu_elam(elem, energy, kind='photo')\n    mu_incoh = mu_elam(elem, energy, kind='incoh')\n    mu_coher = mu_elam(elem, energy, kind='coh')\n\n\n    ax = axs[i]\n\n    ax.set_title(f'X-ray mass attenuation for {elem}')\n    ax.plot(energy_keV, mu_total, linewidth=2, label='Total', alpha=0.5)\n    ax.plot(energy_keV, mu_photo, linewidth=2, label='Photo-electric', alpha=0.5)\n    ax.plot(energy_keV, mu_incoh, linewidth=2, label='Incoherent', alpha=0.5)\n    ax.plot(energy_keV, mu_coher, linewidth=2, label='Coherent', alpha=0.5)\n\n    ax.set_xlabel('Energy (keV)')\n    ax.set_ylabel(r'$\\mu/\\rho \\rm\\, (cm^2/gr)$')\n    #ax.legend()\n    ax.set_yscale('log')\n    \naxs[0].legend();\n\n..\n\n\nI would like to see how scattering depends on atomic number \\(Z\\).\n\nZ0 = xraydb.atomic_number('H')\nZ1 = xraydb.atomic_number('Pb') + 1\nelement_list = [xraydb.atomic_symbol(Z) for Z in range(Z0, Z1)]\nprint(element_list)\n\n['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb']\n\n\n\nenergy = np.arange(500, 25000, 10)  # energy in eV\nenergy_keV = energy / 1000  \n\nelements = element_list\n\nprint(elements)\n\n['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb']\n\n\n\nmu_incoh_list = []\nmu_coh_list = []\nmu_photo_list = []\n\nfor elem in elements: \n    \n    mu_incoh = xraydb.mu_elam(elem, energy, kind='incoh')\n    mu_incoh_list.append(mu_incoh)\n    \n    mu_coh = xraydb.mu_elam(elem, energy, kind='coh')\n    mu_coh_list.append(mu_coh)\n    \n    mu_photo = xraydb.mu_elam(elem, energy, kind='photo')\n    mu_photo_list.append(mu_photo)\n\n\nK = np.array(mu_photo_list)\nS = np.array(mu_coh_list) + np.array(mu_incoh_list) # ignore Compton shift\n\n\ncmap = plt.get_cmap('viridis_r')\ngradient = np.linspace(0, 1, len(elements))\ncolors = cmap(gradient)\n\n\nfig, [ax0, ax1, ax2] = plt.subplots(ncols=3, sharex=True, sharey=True, figsize=[9, 4])\n\nfor i, mu in enumerate(mu_incoh_list): \n    ax0.plot(energy_keV, mu, label=elements[i], color=colors[i]) \n    ax0.set_xlabel('energy (keV)')\n    \nfor i, mu in enumerate(mu_coh_list): \n    ax1.plot(energy_keV, mu, label=elements[i], color=colors[i])\n    ax1.set_xlabel('energy (keV)')\n    \nfor i, mu in enumerate(mu_photo_list): \n    ax2.plot(energy_keV, mu, label=elements[i], color=colors[i])\n    ax2.set_xlabel('energy (keV)')\n\nax0.set_title('incoh')    \nax1.set_title('coh')    \nax2.set_title('photo')  \n\nlogscale = True \nif logscale == True:\n    ax0.set_yscale('log')\n    ax1.set_yscale('log')\n    ax2.set_yscale('log')\n#ax.legend()\n\n..\n\n\nThe question now is if we can explain the lead shadow regions in some of light element peak maps. This problem is essentially combining the effects of scattering and absorption of a translucent layer. To calculate reflectance and transmission properties of such a system we can use the results of Kubelka-Munk theory.\nGiven the relatively small energy shift due to inelastic (incoherent) scattering, we can simplify the problem by summing elastic (coherent) and inelastic (incoherent) scattering into a single scattering coefficient \\(S\\).\n\ndef R_inf(K, S): \n    '''Infinite reflectance from `K` and `S`.\n    \n    Calculation with modified Saunderson equation. '''\n     \n    Rinf =  (S/K) / ((S/K) + 1 + np.sqrt(1 + 2 * (S/K))) \n    \n    return Rinf\n\n\nRinf = R_inf(K, S)\n\n\nRinf.shape\n\n(82, 2450)\n\n\n\nfig, ax = plt.subplots()\n\nextent = [energy_keV.min(), energy_keV.max(), Z0, Z1]\n\nim = ax.imshow(Rinf, interpolation='none', origin='lower', aspect=0.3, extent=extent, cmap='Greys_r')\n\nfig.colorbar(im, ax=ax)\n\nax.set_title(r'Pure element infinite reflectance $R_{\\infty}$')\nax.set_xlabel('Energy (keV)')\nax.set_ylabel('Atomic number (Z)'); \n#ax.set_ylim([0, 20])\n\n..\n\n\nWhat we learn here is that the Compton ridge is essentially only due to the abundance of hydrogen in the paper. The scattering of carbon and oxygen can safely be neglected.\nNext step is the calculation of the transmission of a typical ( \\(200 ~ g/m^2\\)) paper…\n\nmu_paper = xraydb.material_mu('C6H12O6', energy, 0.5)\nmu_lead = xraydb.material_mu('PbCO3', energy, 20)\nmu_iron = xraydb.material_mu('Fe', energy, 10)\n\n\nd_paper = 0.5 # mm \nd_lead = 0.001 # mm \nd_iron = 0.001 # mm \n\nT_paper = np.exp(-d_paper * mu_paper)\nT_lead = np.exp(-d_lead * mu_lead)\nT_iron = np.exp(-d_iron * mu_iron)\n\n\nfig, ax = plt.subplots(figsize=[9, 4])\n\nax.plot(energy_keV, T_paper, label=f'{d_paper}mm paper')\nax.plot(energy_keV, T_lead, label=f'{d_lead}mm lead')\nax.plot(energy_keV, T_iron, label=f'{d_iron}mm iron')\nax.set_title('Transmission')\nax.set_xlabel('energy (keV)')\nax.set_ylabel('transmission')\nax.legend();\n\n..\n\n\nSo, the one million dollar question now is: what is the expected reflectance of the sandwich?",
    "crumbs": [
      "XRF physics - the gory details"
    ]
  },
  {
    "objectID": "speckles.html",
    "href": "speckles.html",
    "title": "Speckles",
    "section": "",
    "text": "Code\nimport numpy as np \nimport matplotlib.pyplot as plt \nimport matplotlib.cm as cm\nimport skimage.exposure as ske\nimport skimage.measure as skm\nimport skimage.morphology as smo\n\nfrom maxrf4u import DataStack\nHistoric handmade papers can contain various types of metal inclusions. Iron and manganese can be abundantly present in groundwater and are notoriously difficult to remove. Hence, historic papers typically contain iron/manganese inclusions. Another source of metal inclusions is the wear of paper making equipment such as the brass wires of a paper making mold.\nThese metal inclusions in paper lead to spikes in the elemental maps computed from MA-XRF data. If one is interested in the distribution of elements due to media like ink, such spikes are annoying and need to be filtered out of the elemental maps. We will develop code here to do so. On the other hand, the composition and distribution of metal inclusions in paper is an interesting new source of information that might reveal details of the paper making process and help to distinguish different papers.\nAutomated detection of speckles can be hard if one encounters situations where the presence of a certain element is due to multiple materials present in the drawing. For the Suzanna drawing his is for example the case with zinc, which is an element present in brass (Cu + Zn) particles and also occurs as an element in the white vitriol (ZnSO4) that seems to be used in the gelatin sizing of the paper.\nA systematic approach would be a multi channel segmentation of the stack of element maps. However for now I do not have time to work on this. So let’s just explore in an ad-hoc fashion the copper and iron inclusions that we encounter…",
    "crumbs": [
      "Speckles"
    ]
  },
  {
    "objectID": "speckles.html#brass-inclusions",
    "href": "speckles.html#brass-inclusions",
    "title": "Speckles",
    "section": "Brass inclusions",
    "text": "Brass inclusions\nThe trouble with speckles is that often they are too small to be directly noticed in an element map without zooming in. Although single pixel can be bright, it doesn’t show up in a full element map plot at limited resolution. Some bright speckles can be made visible with a Gaussian blur filter.\nTo explore the presence of brass particles we need to look at copper and zinc…\nLet’s load image of the drawing as well as the element maps of copper, zinc and sulfur into memory.\n\n\nCode\nds = DataStack('RP-T-1898-A-3689.datastack') \nextent = ds.read('imvis_extent')\nimvis = ds.read('imvis_reg_highres')\n\nelements = ds.read('nmf_elements')\nelement_maps = ds.read('nmf_elementmaps')\nelement_maps_dict = dict(zip(elements, element_maps))\n\nCu_map = element_maps_dict['Cu']\nZn_map = element_maps_dict['Zn']\nS_map = element_maps_dict['S']\n\nCu_map_norm = Cu_map / Cu_map.max()\nZn_map_norm = Zn_map / Zn_map.max()\nS_map_norm = S_map / S_map.max()\n\n\nLet’s plot the Gaussian blurred maps next to the high-res image.\n\n\nCode\nimport skimage.filters as skf\n\n\n\n\nCode\nCu_map_gauss = skf.gaussian(Cu_map, sigma=5)\nZn_map_gauss = skf.gaussian(Zn_map, sigma=5)\nS_map_gauss = skf.gaussian(S_map, sigma=5)\n\n\n\n\nCode\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=[8, 8], sharex=True, sharey=True)\n\naxs = axs.flatten()\n\naxs[0].imshow(imvis, extent=extent)\naxs[1].imshow(Cu_map_gauss, vmax=0.4)\naxs[2].imshow(Zn_map_gauss)\naxs[3].imshow(S_map_gauss, vmax=0.06);\n\nfor i, t in enumerate(['VIS', 'Cu', 'Zn', 'S']): \n    axs[i].set_title(t)\n    \nplt.subplots_adjust()\n\n\n..\n\n\nSeveral observations can me made from these Gaussian blurred and intensity clipped element maps:\n\nOur best possibility to locate brass particles for this specific drawing is the copper map. Although we do find a non-zero copper signal in the paper background of this drawing, it is of lower intensity then the particles. We are lucky here. Other drawings often do contain copper as a constituent of the ink. Altogether we can locate four copper containing particles.\nWith respect to zinc we see that the larger part of the paper background contains zinc, likely due to the gelatin sizing of the paper containing zinc-sulfate. Against this background is difficult to directly extract the zinc signal due to the brass particles. Instead we need to zoom in to the copper regions and check if they correlate with zinc. Additionally we do find a single high concentration of zinc without copper in the upper part of the zinc map at xy=(1029, 231).\nAlthough one would expect sulfur to correlate with zinc sulphate present in the sizing, the sulfur map does not show this correlation. Probably the low intensity sulfur signal due to the zinc-sulfate can not be separated from the elastic scattering of the background.\n\n\n\nCode\nCu_clip = Cu_map_gauss &gt; 0.28 \nZn_clip = Zn_map_gauss &gt; 0.7\nCu_Zn_mask = Cu_clip + Zn_clip\n\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=[8, 8], sharex=True, sharey=True, constrained_layout=True)\n\naxs = axs.flatten()\n\naxs[0].imshow(imvis, extent=extent)\naxs[1].imshow(Cu_map_gauss, vmax=0.3)\naxs[2].imshow(Zn_map_gauss)\naxs[3].imshow(Cu_Zn_mask);\n\nfor i, t in enumerate(['VIS', 'Cu', 'Zn', 'Cu+Zn particles']): \n    axs[i].set_title(t)\n\n\n..\n\n\nWe can now use the copper plus zinc particles mask to mark all individual particles using the skimage.measure.label() function.\n\n\nCode\nlabeled_image = skm.label(Cu_Zn_mask)\nn_particles = labeled_image.max()\nn_particles\n\n\n7\n\n\nWe have found 7 particles. Let’s add circle markers to the plot above.\n\n\nCode\ncolors = cm.tab20(range(n_particles))\n\nprops = skm.regionprops_table(labeled_image, properties=['centroid'])\ncy = props['centroid-0']\ncx = props['centroid-1']\n\naxs[3].scatter(cx, cy, marker='s', s=80, facecolors='none', edgecolors=colors)\nfor i in range(n_particles):\n    axs[3].text(cx[i]-30, cy[i]-60, i+1, color=colors[i])\n\n\nNow let’s create an overview plot with all particles zoomed in.\n\n\nCode\nh = 15 # half height \n\nxlim_list = []\nylim_list = []\n\nfor i, [xi, yi] in enumerate(zip(cx, cy)): \n    \n    xlim = [int(xi) - h, int(xi) + h]\n    xlim_list.append(xlim)\n    \n    ylim = [int(yi) + h, int(yi) - h]\n    ylim_list.append(ylim) \n\nlabels = ['particle 1\\nzinc only', 'particle 2\\ncopper', 'particle 3\\nbrass', 'particle 4\\nbrass', \n          'particle 5\\nbrass', 'particle 6\\nbrass', 'particle 7\\ncopper']\n\nfig, axs = plt.subplots(nrows=n_particles, ncols=3, figsize=[8, n_particles*2.7], constrained_layout=True)\n\n    \nfor i, [xlim, ylim] in enumerate(zip(xlim_list, ylim_list)): \n\n    axs[i, 0].imshow(imvis, extent=extent)\n    axs[i, 0].set_xlim(xlim)\n    axs[i, 0].set_ylim(ylim)\n    axs[i, 0].set_xticks([])\n    axs[i, 0].set_yticks([])\n    axs[i, 0].text(0.05, 0.85, labels[i], transform=axs[i, 0].transAxes)\n    #axs[i, 0].set_ylabel('hi')\n    \n    axs[i, 1].imshow(Cu_map, vmax=2)\n    axs[i, 1].set_xlim(xlim)\n    axs[i, 1].set_ylim(ylim)\n    axs[i, 1].set_xticks([])\n    axs[i, 1].set_yticks([])\n       \n    axs[i, 2].imshow(Zn_map, vmax=2)\n    axs[i, 2].set_xlim(xlim)\n    axs[i, 2].set_ylim(ylim)\n    axs[i, 2].set_ylim(ylim)\n    axs[i, 2].set_xticks([])\n    axs[i, 2].set_yticks([])\n\naxs[0,0].set_title('VIS')\naxs[0,1].set_title('Cu')\naxs[0,2].set_title('Zn');\n\n\n..\n\n\nFollowing the ad-hoc method described above, we find five brass particles, two copper particles and one brown fiber inclusion with zinc only.",
    "crumbs": [
      "Speckles"
    ]
  },
  {
    "objectID": "storage.html",
    "href": "storage.html",
    "title": "Storage",
    "section": "",
    "text": "Macro-X-Ray-Fluorescence (MA-XRF) data typically do not fit into memory. In order to make optimal use of your computer memory and multi-core processors it is therefore necessary to convert such spectral data into a chunked analysis ready file format. The maxrf4u package makes use of a specially developed .datastack file format.\nIn all of the data processing below we will store both the raw data and the results of further computations on disk in a .datastack file. The file format is based on the ZipStore file format of the zarr python package.",
    "crumbs": [
      "Storage"
    ]
  },
  {
    "objectID": "storage.html#checking-the-scan-orientation",
    "href": "storage.html#checking-the-scan-orientation",
    "title": "Storage",
    "section": "Checking the scan orientation",
    "text": "Checking the scan orientation\nBefore we start our heavy computing, we need to inspect the orientation of the MA-XRF scan data as stored in the .raw file. This can be done with the make_raw_preview() function.\n\nfrom maxrf4u import make_raw_preview\n\n\nmake_raw_preview('RP-T-1898-A-3689.raw', 'RP-T-1898-A-3689.rpl', show=True);\n\nSaving: RP-T-1898-A-3689.raw_preview.png...\n\n\n\n\n\n\n\n\n\nWe see here that the orientation of the raw scan data is rotated 180 degrees. In our next computations we need to take this into account.",
    "crumbs": [
      "Storage"
    ]
  },
  {
    "objectID": "storage.html#creating-a-.datastack-file-to-do-out-of-memory-calculations",
    "href": "storage.html#creating-a-.datastack-file-to-do-out-of-memory-calculations",
    "title": "Storage",
    "section": "Creating a .datastack file to do out-of-memory calculations",
    "text": "Creating a .datastack file to do out-of-memory calculations\nIn this example below we show how to convert a MA-XRF dataset consisting of a .raw data cube file (and an .rpl shape file) into a .datastack file. During conversion the maxrf4u.raw_to_datastack() function performs a Gaussian smoothing of each spectrum. Also the max and sum spectra are computed and stored.\nOn my new laptop this initial conversion of a 21 Gb dataset takes 10:23 minutes.\n\nfrom maxrf4u import raw_to_datastack, tree\n\n\nraw_to_datastack('RP-T-1898-A-3689.raw', 'RP-T-1898-A-3689.rpl', flip_horizontal=True, flip_vertical=True)\n\nPlease wait while preparing data conversion...\nCreating memory map...\nWriting: RP-T-1898-A-3689.datastack...\n[########################################] | 100% Completed | 111.42 s\nComputing max spectrum...\n[########################################] | 100% Completed | 217.51 s\nComputing sum spectrum...\n[########################################] | 100% Completed | 223.72 s\n\n\nIt is now possible to check the content (i.e. the datasets) of the .datastack file with the tree() function.\n\ntree('RP-T-1898-A-3689.datastack')\n\nRP-T-1898-A-3689.datastack:\n\n/\n ├── maxrf_cube (1692, 1592, 4096) float32\n ├── maxrf_maxspectrum (4096,) float32\n └── maxrf_sumspectrum (4096,) float64\n\n\nWith the show_arrays=True option the tree() function also shows the shapes and chunk sizes of the individual datasets. For example, the maxrf_cube dataset contains 1692 x 1592 spectra with 4096 channels each.\n\ntree('RP-T-1898-A-3689.datastack', show_arrays=True)\n\nRP-T-1898-A-3689.datastack:\n\n/\n ├── maxrf_cube (1692, 1592, 4096) float32\n ├── maxrf_maxspectrum (4096,) float32\n └── maxrf_sumspectrum (4096,) float64\n\n\n- Dataset: maxrf_cube\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n41.10 GiB\n127.36 MiB\n\n\nShape\n(1692, 1592, 4096)\n(322, 322, 322)\n\n\nDask graph\n390 chunks in 2 graph layers\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                                                   4096 1592 1692\n\n\n\n\n- Dataset: maxrf_maxspectrum\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n16.00 kiB\n16.00 kiB\n\n\nShape\n(4096,)\n(4096,)\n\n\nDask graph\n1 chunks in 2 graph layers\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n         4096 1\n\n\n\n\n- Dataset: maxrf_sumspectrum\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n32.00 kiB\n32.00 kiB\n\n\nShape\n(4096,)\n(4096,)\n\n\nDask graph\n1 chunks in 2 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n         4096 1\n\n\n\n\n\n\nWith the freshly created .datastack file it is now possible to further explore and process the data. Let’s start this exploration by plotting numpy arrays that are returned by the .read(&lt;datapath&gt;) methods. The max and sum spectra provide a good summary of the spectral data. The horizontal axis shows the detector channel numbers. Note that inconveniently the data does not provide an energy calibration yet.\n\nfrom maxrf4u import DataStack\n\n\nds = DataStack('RP-T-1898-A-3689.datastack')\n\n\nimport matplotlib.pyplot as plt \nimport numpy as np\n\n\ny_max = ds.read('maxrf_maxspectrum')\ny_sum = ds.read('maxrf_sumspectrum')\n\nfig, ax = plt.subplots(figsize=[8, 5])\nax2 = ax.twinx()\nax.fill_between(np.arange(len(y_max)), y_max, color='r', alpha=0.3)\nax2.plot(y_sum, color='g', alpha=0.7)\nax.set_title('Smoothed XRF max and sum spectra')\nax.set_xlabel('Channels [#]')\nax.set_ylabel('Max spectrum Intensity [Counts] (red)')\nax2.set_ylabel('Sum spectrum Intensity [Counts] (green)');",
    "crumbs": [
      "Storage"
    ]
  },
  {
    "objectID": "storage.html#appending-and-reading-arrays-and-ragged-lists",
    "href": "storage.html#appending-and-reading-arrays-and-ragged-lists",
    "title": "Storage",
    "section": "Appending and reading arrays and ragged lists",
    "text": "Appending and reading arrays and ragged lists\nIn the code above a new .datastack file was created to store the converted MA-XRF data and further computations. If these computed results are shaped as a regular array one can use the append() function and DataStack.read() method for writing to and reading from the .datastack file.\nHowever, we will also come across situations in which we want to store and read irregular (ragged) lists of lists. In these cases one needs to make use of the append_list() function and the DataStack.read_list() method.\nHere is a small example to demonstrate this functionality.\n\nfrom maxrf4u import append_list, DataStack\n\n\n# write \nmy_test_ragged_list = [[1, 2], [3, 5, 7], [1]]\nappend_list(my_test_ragged_list, 'test_list', 'RP-T-1898-A-3689.datastack')\n\n# and read \nds = DataStack('RP-T-1898-A-3689.datastack')\nds.read_list('test_list')\n\n[[1, 2], [3, 5, 7], [1]]",
    "crumbs": [
      "Storage"
    ]
  },
  {
    "objectID": "storage.html#functions",
    "href": "storage.html#functions",
    "title": "Storage",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nDataStack\n\n DataStack (datastack_file, mode='r', verbose=False, show_arrays=True)\n\nInitialize DataStack object from datastack_file.\n\nsource\n\n\nparse_rpl\n\n parse_rpl (rpl_file, verbose=False)\n\nRead .rpl shape file and return shape and dtype.\n\nsource\n\n\nmake_raw_preview\n\n make_raw_preview (raw_file, rpl_file, output_dir=None, show=False,\n                   save=True, verbose=False)\n\nCreate preview image of raw file to inspect scan orientation.\n\nsource\n\n\nmax_and_sum_spectra\n\n max_and_sum_spectra (datastack_file, datapath='maxrf_cube',\n                      chunks='auto')\n\nCompute sum spectrum and max spectrum for ‘maxrf’ dataset in datastack_file*.\nReturns: y_sum, *y_max**\n\nsource\n\n\nrepack\n\n repack (datastack_file, select='all', overwrite=True, verbose=False)\n\nRepack datastack_file* by deleting and renaming all but latest datasets.\nAutomatic selection of latest datasets can be overriden be providing list of select datasets*\n\nsource\n\n\nappend_list\n\n append_list (ragged_list, datapath, datastack_file, nan=-9999)\n\n*Wrapper around append() to store iregular (ragged) lists of lists as regular padded arrays.\nCurrently only working for two dimensional lists of integers. Padding is done with nan=-9999.*\n\nsource\n\n\nappend\n\n append (arr, datapath, datastack_file)\n\nAdd numpy or dask array arr* to datastack_file in folder datapath.*\n\nsource\n\n\nunderscorify\n\n underscorify (datapath, datapath_list, extra_underscore=True)\n\nAppend extra underscore if datapath* exists to prevent overwriting.\nIf extra_underscore=False return (latest) datapath with most underscores*\n\nsource\n\n\ntree\n\n tree (datastack_file, show_arrays=False)\n\nPrints content tree of datastack_file**\n\nsource\n\n\nraw_to_datastack\n\n raw_to_datastack (raw_file, rpl_file, output_dir=None,\n                   datapath='maxrf_cube', verbose=True,\n                   flip_horizontal=False, flip_vertical=False, chunks='10\n                   MiB', rechunk=False)\n\n*Convert Bruker Macro XRF (.raw) data file raw_filename and (.rpl) shape file rpl_filename.\ninto a zarr ZipStore datastack file (.datastack).\nTo avoid memory problems on computers with less RAM the chunks option is set to ‘10 MiB’.*\n\nsource\n\n\nLayers\n\n Layers ()\n\nInitialize self. See help(type(self)) for accurate signature.",
    "crumbs": [
      "Storage"
    ]
  },
  {
    "objectID": "peakmaps.html",
    "href": "peakmaps.html",
    "title": "Distribution maps",
    "section": "",
    "text": "In the previous section we explored spectra and developed an intuition for solving the peak pattern puzzle that each spectrum presents. Every x-ray fluorescence spectrum in our data cube is a sum of spectral patterns due to the presence of a mixture of chemical elements present at the measurement spot. These spectra are further complicated by 1) the presence of a continuum baseline caused by elastic and inelastic scattering of the paper background, and 2) Poisson photon noise. In other words, spectra contain mixed signals.\nIn order to arrive at element or material distribution maps, we now need to mathematically unmix the one million spectra from our data cube. Technically speaking we have to factorize our data cube \\(X\\) into components \\(H\\) and weights \\(W\\)(concentrations).\n\\[ X \\approx H \\times W \\]\nDifferent mathematical techniques have been developed for decomposing spectra into it’s components. Best suited to our needs is a technique called Non-negative Matrix Factorization (NMF). Unlike other algorithms the NMF algorithm ensures that both the computed component spectra and their concentrations can not be negative.",
    "crumbs": [
      "Distribution maps"
    ]
  },
  {
    "objectID": "peakmaps.html#nonnegative-matrix-factorization-twice",
    "href": "peakmaps.html#nonnegative-matrix-factorization-twice",
    "title": "Distribution maps",
    "section": "Nonnegative Matrix Factorization twice",
    "text": "Nonnegative Matrix Factorization twice\nThe NMF algorithm is implemented in the scikit learn package and is fairly straightforward to use. In our case however we need to take into account that our data cube does not fit into memory all at once. As a workaround I will unmix/simplify the spectral data in two steps, applying the NMF algorithm twice.\nStep 1: Gaussian peak fitting\nIn a first step we need to resolve the problem of overlapping peak regions using NMF. This is done by first fitting Gaussian shaped peak profiles the all hotmax pixel peaks in all hotmax spectra. In order to get an idea what this means let’s first fit the max spectrum using the fit_spectrum_peaks() function and plot the result. The output of the fit function is an array of weights w and the corresponding array of Gaussian peak profiles H.\n\nfrom maxrf4u import fit_spectrum_peaks\n\n\nw, H = fit_spectrum_peaks(y_max, 'RP-T-1898-A-3689.datastack') \nfitted_list = w * H\n\n\n\nCode\nfig, ax = plt.subplots(figsize=[7, 5])\n    \ny_cont = fitted_list[-1]\n\nfor y_fit in fitted_list[:-1]: \n    ax.fill_between(x_keVs, y_fit + y_cont, y_cont, where=(y_fit&gt;0.001), alpha=0.7) \n\nax.plot(x_keVs, y_max,c='r', alpha=0.4, label='max spectrum')\nax.plot(x_keVs, y_cont, c='grey', label='continuum', ) \nax.set_xlim([-2, 25])\nax.set_xlabel('energy (keV)')\nax.set_ylabel('Intensity (#counts)')\nax.set_title('Fitted Gaussian peak profiles')\nax.legend()\n\n\n\n\n\n\n\n\n\nAlthough some peaks overlap one can see that they are now separated (and filled with different colors) using the NMF algorithm. We can now repeat the same procedure for all spectra in the data cube to produce peak maps. This can be done using the compute_nmf_peakmaps() function. On my laptop this takes 5m 14s.\n\nfrom maxrf4u import compute_nmf_peakmaps, multi_plot\n\n\npeak_maps = compute_nmf_peakmaps('RP-T-1898-A-3689.datastack')\n\nPlease wait a few minutes while preparing your peak maps. \nComputing factorization for spectral chunk 30/30...\n\n\nWrite peak maps factorization to datastack file [y/n]?  y\n\n\n\nSaved NMF peak maps data to: RP-T-1898-A-3689.datastack\n\n\nTo get a first idea of the patterns in the peak maps let’s histogram equalize the images for maximum contrast and plot the results.\n\n\nCode\n# no need to compute again \n# we can read our saved peak maps from datastack file \nds = DataStack('RP-T-1898-A-3689.datastack')\npeak_maps = ds.read('nmf_peakmaps')\n\npeak_maps_histeq = [ske.equalize_hist(pm) for pm in peak_maps]\n\ntitles = [f'[{i}]' for i in range(len(peak_maps) - 1)]\ntitles.append('Continuum')\n\nmulti_plot(*peak_maps_histeq, titles=titles, svg=True)\n\n\n\n\n\n\n\n\n\nStep 2) From peak maps to element maps\nFrom our peak pattern puzzle in the previous section we found by inspection that the following 11 elements seem to be present in the Susanna drawing: sulfur (S), chlorine (Cl), potassium (K), calcium (Ca), barium (Ba), titanium (Ti), manganese (Mn), iron (Fe), copper (Cu), zinc (Zn) and lead (Pb). In order to compute 11 element maps from 24 peak maps we first need an atlas of spectra for these elements of interest. To create a spectrum for a single element we can use the function get_element_spectrum. For multiple elements we can use the function get_element_spectra().\n\n# found elements \nfound_elems = ['S', 'Ca', 'K', 'Cl', 'Fe', 'Mn', 'Cu', 'Zn', 'Pb', 'Ti', 'Ba']\n\n\nfrom maxrf4u import get_element_spectra, colorize \nfrom maxrf4u.peakmaps import _add_hotlines_ticklabels\n\n\nelements, element_spectra = get_element_spectra(found_elems, x_keVs, excitation_energy_keV=25) # sorted by largest peak\n\nLet’s plot them see how the theoretical element spectra look like.\n\n\nCode\nn_elements = len(elements) \n\nhotlines = x_keVs[ds.read('hotmax_peak_idxs_flat')]\n\nfig, axs = plt.subplots(nrows=n_elements, sharex=True, figsize=[8, 8])\n\nfor i, s in enumerate(element_spectra): \n    \n    elem = elements[i]\n    color = colorize(elem)\n    \n    axs[i].plot(x_keVs, s, color=color) \n    #_add_hotlines_ticklabels('RP-T-1898-A-3689.datastack', axs[i])\n    #axs[i].fill_between(x_keVs, nmf_fitted[i], color=color, alpha=0.6)\n    axs[i].set_yticks([0.5], labels=[elem])\n    [axs[i].axvline(x, color='r', alpha=0.2, zorder=9-30) for x in hotlines]\n    \naxs[0].set_xlim([-1, 20])\naxs[0].set_xlabel('Energy (keV)')\n\n_add_hotlines_ticklabels('RP-T-1898-A-3689.datastack', axs[0], vlines=False)\n\naxs[0].set_title('Selected element spectra')\naxs[-1].set_xlabel('Energy (keV)')\n\nplt.subplots_adjust(hspace=0.2);\n\n\n\n\n\n\n\n\n\nGiven all our preparations above, we can now compute our much appreciated element maps, again using the NMF algorithm with the function compute_nmf_element_maps().\n\nfrom maxrf4u import compute_nmf_element_maps\n\n\nelements, element_maps = compute_nmf_element_maps('RP-T-1898-A-3689.datastack', elements)\n\nPreparing peaks to elements transformation matrix...\nComputing element maps for ['S', 'Cl', 'K', 'Ca', 'Ba', 'Ti', 'Mn', 'Fe', 'Cu', 'Zn', 'Pb']...\nReady computing!\n\n\n\nWrite NMF element maps and factorization data to datastack file [y/n]?  y\n\n\n\nSaved NMF element maps and factorization data to: RP-T-1898-A-3689.datastack\n\n\n\n\nCode\nfrom maxrf4u import multi_plot\n\n\n\n# no need to compute again \nds = DataStack('RP-T-1898-A-3689.datastack')\n\nx_keVs = ds.read('maxrf_energies')\nelements = ds.read('nmf_elements')\nelement_maps = ds.read('nmf_elementmaps')\n\nelement_maps_histeq = [ske.equalize_hist(m) for m in element_maps]\n\nmulti_plot(*element_maps_histeq, titles=elements, svg=True)",
    "crumbs": [
      "Distribution maps"
    ]
  },
  {
    "objectID": "peakmaps.html#functions",
    "href": "peakmaps.html#functions",
    "title": "Distribution maps",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nraw_to_element_maps\n\n raw_to_element_maps (elements_unsorted, raw_file, rpl_file,\n                      output_dir=None, chunks='10 MiB', auto_write=True,\n                      n_steps=7)\n\n*Convert Bruker Macro XRF (.raw) data file raw_filename and (.rpl) shape file rpl_filename\ninto element maps based on the list elements_unsorted.\nRunning into memory errors? see: dask.array.core.normalize_chunks for chunk options.*\n\nsource\n\n\ncompute_nmf_element_maps\n\n compute_nmf_element_maps (datastack_file, elements_unsorted,\n                           excitation_energy_keV=25, auto_write=False)\n\n*Compute element maps for elements list.\nBased on NMF factorization. Requires previously computed peak maps stored in datastack_file. Sorts elements according to strongest (a.k.a. alpha) peak. Ask user to save results.\nReturns: elements, element_maps*\n\nsource\n\n\nmulti_plot\n\n multi_plot (*images, hot_pixel=None, titles=None, roi_list=None,\n             axis_off=False, sharex=True, sharey=True, vmin=None,\n             vmax=None, cmap='viridis', fontsize='medium', zoom_xyc=None,\n             zoom_half_wh=[100, 100], svg=False)\n\n*Inspect multiple images simultaneously…\nFold along multiple rows if n &gt; 4*\n\nsource\n\n\ncompute_nmf_peakmaps\n\n compute_nmf_peakmaps (datastack_file, auto_write=False)\n\n*Use nonnegative matrix factorization to compute peak maps spectral data in datastack_file.\nIf option auto_write is false (default), ask user permission to write result to datastack file.\nReturns: peak_maps*\n\nsource\n\n\nfit_spectrum_peaks\n\n fit_spectrum_peaks (y, datastack_file)\n\n*Fit Gaussian peak shapes to single spectrum y.\nUses NMF with fixed Gaussian component vectors.\nReturns: weighed_components_list*\n\nsource\n\n\nget_gaussians\n\n get_gaussians (datastack_file, tail_clip=0.05, norm=True)\n\n*Fit Gaussian peak profiles to hotmax peaks in hotmax atlas.\nReturns: y_gauss_list*\n\nsource\n\n\nget_continuum\n\n get_continuum (datastack_file)\n\n*Compute continuum baseline from sum spectrum.\nUses rolling ball filter to remove peaks from sum spectrum.\nReturns: y_continuum*",
    "crumbs": [
      "Distribution maps"
    ]
  },
  {
    "objectID": "peak-pattern-puzzle-solver.html",
    "href": "peak-pattern-puzzle-solver.html",
    "title": "Solving the peak pattern puzzle",
    "section": "",
    "text": "In the previous section we saw how to explain the presence of specific in the individual hotmax spectra by comparison with the instrument and element peak patterns by hand. Tedious work, but not too difficult. Let’s now try to extract the algorithm for solving the peak pattern puzzle. As an example let’s walk through hotmax spectrum #4. In the plot we see thirteen peaks that exceed the noise threshold. We need to explain these peaks away, one by one…\n\nfrom maxrf4u import plot_puzzle, HotmaxAtlas, DataStack\n\n\nfig, ax, ax1 = plot_puzzle('RP-T-1898-A-3689.datastack', 4, color_select=[])\nax.set_title('Peak pattern atlas');\n\n..\n\n\nInitially, in hotmax spectrum #4 there are thirteen detected peaks that we need to explain. These peaks are numbered from highest to lowest. Let’s see how we can explain them away one by one. To read the thirteen peak indexes, we can use the DataStack.read_list() method. Note that in this case we can not use the standard DataStack.read() method because the data in the datastack is stored as a ragged list.\nHere are the 13 sub peak indexes of hotmax spectrum #4.\n\nds = DataStack('RP-T-1898-A-3689.datastack')\n\n\nsubpeak_idxs = ds.read_list('hotmax_subpeak_idxs_list')[4]\nsubpeak_idxs\n\n[95, 1981, 466, 735, 427, 329, 2108, 800, 2206, 1360, 152, 1522, 933]\n\n\nLet’s convert these channel indexes into energies first.\n\nx_keVs = ds.read('maxrf_energies')\npeak_nums = np.arange(len(subpeak_idxs))\npeak_keVs = x_keVs[subpeak_idxs]\n\n\nwhy_df = pd.DataFrame(data={'keVs': peak_keVs})\nwhy_df.index.name = 'n'\nwhy_df['why'] = '?'\nwhy_df\n\n\n\n\n\n\n\n\nkeVs\nwhy\n\n\nn\n\n\n\n\n\n\n0\n-0.028648\n?\n\n\n1\n18.895640\n?\n\n\n2\n3.693998\n?\n\n\n3\n6.393168\n?\n\n\n4\n3.302669\n?\n\n\n5\n2.319328\n?\n\n\n6\n20.169969\n?\n\n\n7\n7.045383\n?\n\n\n8\n21.153309\n?\n\n\n9\n12.664472\n?\n\n\n10\n0.543295\n?\n\n\n11\n14.289994\n?\n\n\n12\n8.379917\n?\n\n\n\n\n\n\n\n\n\n\narray([-0.02864804, 18.89563968,  3.69399816,  6.39316751,  3.30266878,\n        2.31932827, 20.16996871,  7.04538316, 21.15330921, 12.66447177,\n        0.5432949 , 14.28999383,  8.3799167 ])\n\n\n\nexplanation = [{'n': n, 'keV': keV, 'src': src} for n, keV, src in zip(peak_nums, peak_keVs, peak_srcs)]\nexplanation\n\n[{'n': 0, 'keV': -0.028648044952708673, 'src': '????'},\n {'n': 1, 'keV': 18.895639680305266, 'src': '????'},\n {'n': 2, 'keV': 3.693998161871633, 'src': '????'},\n {'n': 3, 'keV': 6.393167513989552, 'src': '????'},\n {'n': 4, 'keV': 3.3026687762485896, 'src': '????'},\n {'n': 5, 'keV': 2.3193282687855556, 'src': '????'},\n {'n': 6, 'keV': 20.16996870528287, 'src': '????'},\n {'n': 7, 'keV': 7.0453831566946254, 'src': '????'},\n {'n': 8, 'keV': 21.153309212745903, 'src': '????'},\n {'n': 9, 'keV': 12.664471770769104, 'src': '????'},\n {'n': 10, 'keV': 0.5432949032655865, 'src': '????'},\n {'n': 11, 'keV': 14.289993834126363, 'src': '????'},\n {'n': 12, 'keV': 8.379916702537315, 'src': '????'}]\n\n\nNow, we need to consult the peak pattern atlas with all element starting with the instrument peak pattern.\n\nfrom maxrf4u import get_patterns, get_instrument_pattern\nimport numpy as np\n\n\ninstr_ptrn = get_instrument_pattern('RP-T-1898-A-3689.datastack')\ninstr_ptrn\n\n{'name': 'INSTRUMENT',\n 'instrument_peaks': array([-0.02864804, 18.82674463, 20.20010005, 20.99840233, 22.72136068])}\n\n\nWe now need to check which peaks in the hotmax spectrum match the instrument peaks.\n\ninstr_keVs = instr_ptrn['instrument_peaks']\ninstr_keVs\n\narray([-0.02864804, 18.82674463, 20.20010005, 20.99840233, 22.72136068])\n\n\nLet’s see which peaks match within a distance of 0.1 keV.\n\ndef match_instrument(why_df, datastack_file, delta_keV=0.1): \n    \n    # first generate instrument pattern\n    instr_ptrn = get_instrument_pattern(datastack_file) \n    instr_keVs = instr_ptrn['instrument_peaks'] \n    \n    # calculate distances and filter &lt; delta_keV\n    distance_matrix = np.sqrt((subpeak_keVs[:, None] - instr_keVs[None, :])**2)\n    is_nearby = distance_matrix &lt; delta_keV\n    \n    # matching peak_nums \n    peak_matches = np.argwhere(is_nearby)[:, 0] \n    \n    # insert cause \n    why_df.at[peak_matches, 'why'] = 'INSTR'\n    \n    return why_df\n\n\nwhy_df = match_instrument(why_df, 'RP-T-1898-A-3689.datastack')\nwhy_df\n\n\n\n\n\n\n\n\nkeVs\nwhy\n\n\nn\n\n\n\n\n\n\n0\n-0.028648\nINSTR\n\n\n1\n18.895640\nINSTR\n\n\n2\n3.693998\n?\n\n\n3\n6.393168\n?\n\n\n4\n3.302669\n?\n\n\n5\n2.319328\n?\n\n\n6\n20.169969\nINSTR\n\n\n7\n7.045383\n?\n\n\n8\n21.153309\n?\n\n\n9\n12.664472\n?\n\n\n10\n0.543295\n?\n\n\n11\n14.289994\n?\n\n\n12\n8.379917\n?\n\n\n\n\n\n\n\nNext phase is a comparison with the element patterns. In order to match a certain element, at least the alpha peak needs to be present…\n\n\n\n[{'elem': 'N',\n  'name': 'Nitrogen',\n  'peaks_xy': array([[0.3902, 1.    ]]),\n  'alpha_escape_keV': -1.3498049024512255,\n  'color': array([0.6196, 0.8549, 0.898 ])},\n {'elem': 'O',\n  'name': 'Oxygen',\n  'peaks_xy': array([[0.5253, 1.    ]]),\n  'alpha_escape_keV': -1.2147373686843421,\n  'color': array([0.0902, 0.7451, 0.8118])},\n {'elem': 'F',\n  'name': 'Fluorine',\n  'peaks_xy': array([[0.6753, 1.    ]]),\n  'alpha_escape_keV': -1.0646623311655827,\n  'color': array([0.8588, 0.8588, 0.5529])},\n {'elem': 'Ne',\n  'name': 'Neon',\n  'peaks_xy': array([[0.8554, 1.    ]]),\n  'alpha_escape_keV': -0.8845722861430715,\n  'color': array([0.7373, 0.7412, 0.1333])},\n {'elem': 'Na',\n  'name': 'Sodium',\n  'peaks_xy': array([[1.0355, 1.    ]]),\n  'alpha_escape_keV': -0.7044822411205602,\n  'color': array([0.7804, 0.7804, 0.7804])},\n {'elem': 'Mg',\n  'name': 'Magnesium',\n  'peaks_xy': array([[1.2606, 1.    ]]),\n  'alpha_escape_keV': -0.47936968484242115,\n  'color': array([0.498, 0.498, 0.498])},\n {'elem': 'Al',\n  'name': 'Aluminum',\n  'peaks_xy': array([[1.4857, 1.    ]]),\n  'alpha_escape_keV': -0.25425712856428206,\n  'color': array([0.9686, 0.7137, 0.8235])},\n {'elem': 'Si',\n  'name': 'Silicon',\n  'peaks_xy': array([[1.7409, 1.    ]]),\n  'alpha_escape_keV': 0.0008704352176087671,\n  'color': array([0.8902, 0.4667, 0.7608])},\n {'elem': 'P',\n  'name': 'Phosphorus',\n  'peaks_xy': array([[2.011, 1.   ]]),\n  'alpha_escape_keV': 0.2710055027513756,\n  'color': array([0.7686, 0.6118, 0.5804])},\n {'elem': 'S',\n  'name': 'Sulfur',\n  'peaks_xy': array([[2.3112, 1.    ]]),\n  'alpha_escape_keV': 0.5711555777888944,\n  'color': array([1. , 0.9, 0.1])},\n {'elem': 'Cl',\n  'name': 'Chlorine',\n  'peaks_xy': array([[2.6263, 1.    ]]),\n  'alpha_escape_keV': 0.8863131565782891,\n  'color': array([0.7725, 0.6902, 0.8353])},\n {'elem': 'K',\n  'name': 'Potassium',\n  'peaks_xy': array([[3.3167, 1.    ],\n         [3.5868, 0.1163]]),\n  'alpha_escape_keV': 1.5766583291645826,\n  'color': array([0.5804, 0.4039, 0.7412])},\n {'elem': 'Ca',\n  'name': 'Calcium',\n  'peaks_xy': array([[3.6918, 1.    ],\n         [4.007 , 0.1254]]),\n  'alpha_escape_keV': 1.9518459229614809,\n  'color': array([1.    , 0.5961, 0.5882])},\n {'elem': 'I',\n  'name': 'Iodine',\n  'peaks_xy': array([[3.932 , 1.    ],\n         [4.2471, 0.9089],\n         [5.0725, 0.106 ],\n         [4.8024, 0.0827],\n         [3.4817, 0.0379]]),\n  'alpha_escape_keV': 2.191965982991496,\n  'color': array([0.6978, 0.5209, 0.4799])},\n {'elem': 'Ba',\n  'name': 'Barium',\n  'peaks_xy': array([[4.4572, 1.    ],\n         [4.8474, 0.8766],\n         [5.1626, 0.1669],\n         [5.8079, 0.1019],\n         [5.5378, 0.0946],\n         [3.947 , 0.0386]]),\n  'alpha_escape_keV': 2.717228614307153,\n  'color': array([0.8566, 0.8005, 0.8976])},\n {'elem': 'Ti',\n  'name': 'Titanium',\n  'peaks_xy': array([[4.5023, 1.    ],\n         [4.9375, 0.1303],\n         [0.4352, 0.0136]]),\n  'alpha_escape_keV': 2.7622511255627815,\n  'color': array([0.8392, 0.1529, 0.1569])},\n {'elem': 'V',\n  'name': 'Vanadium',\n  'peaks_xy': array([[4.9525, 1.    ],\n         [5.4327, 0.1316],\n         [0.5103, 0.0173]]),\n  'alpha_escape_keV': 3.2124762381190592,\n  'color': array([0.5961, 0.8745, 0.5412])},\n {'elem': 'Cr',\n  'name': 'Chromium',\n  'peaks_xy': array([[5.4177, 1.    ],\n         [5.943 , 0.1292],\n         [0.5703, 0.0209]]),\n  'alpha_escape_keV': 3.6777088544272134,\n  'color': array([0.1725, 0.6275, 0.1725])},\n {'elem': 'Mn',\n  'name': 'Manganese',\n  'peaks_xy': array([[5.8979, 1.    ],\n         [6.4832, 0.1337],\n         [0.6303, 0.0231]]),\n  'alpha_escape_keV': 4.157948974487244,\n  'color': array([1.    , 0.7333, 0.4706])},\n {'elem': 'Fe',\n  'name': 'Iron',\n  'peaks_xy': array([[6.3932, 1.    ],\n         [7.0535, 0.1351],\n         [0.7054, 0.0282]]),\n  'alpha_escape_keV': 4.653196598299149,\n  'color': array([0.7, 0.5, 0.1])},\n {'elem': 'Co',\n  'name': 'Cobalt',\n  'peaks_xy': array([[6.9185, 1.    ],\n         [7.6538, 0.1361],\n         [0.7804, 0.0308]]),\n  'alpha_escape_keV': 5.178459229614807,\n  'color': array([0.6824, 0.7804, 0.9098])},\n {'elem': 'Ni',\n  'name': 'Nickel',\n  'peaks_xy': array([[7.4737, 1.    ],\n         [8.2691, 0.1363],\n         [0.8554, 0.0326]]),\n  'alpha_escape_keV': 5.733736868434217,\n  'color': array([0.1216, 0.4667, 0.7059])},\n {'elem': 'Cu',\n  'name': 'Copper',\n  'peaks_xy': array([[8.044 , 1.    ],\n         [8.8994, 0.1347],\n         [0.9305, 0.0342]]),\n  'alpha_escape_keV': 6.304022011005502,\n  'color': array([0.1, 0.9, 0.3])},\n {'elem': 'Zn',\n  'name': 'Zinc',\n  'peaks_xy': array([[8.6293, 1.    ],\n         [9.5748, 0.1385],\n         [1.0205, 0.0355]]),\n  'alpha_escape_keV': 6.889314657328665,\n  'color': array([0.2361, 0.8382, 0.8824])},\n {'elem': 'Hg',\n  'name': 'Mercury',\n  'peaks_xy': array([[ 9.98  ,  1.    ],\n         [11.8409,  0.7195],\n         [ 2.2211,  0.2312],\n         [13.8369,  0.125 ],\n         [11.5558,  0.0617],\n         [ 8.7194,  0.0541],\n         [14.2121,  0.0365],\n         [ 1.7109,  0.0263],\n         [10.6403,  0.017 ]]),\n  'alpha_escape_keV': 8.239989994997499,\n  'color': array([0.7215, 0.5805, 0.8355])},\n {'elem': 'As',\n  'name': 'Arsenic',\n  'peaks_xy': array([[10.5353,  1.    ],\n         [11.7209,  0.1511],\n         [ 1.2906,  0.0424]]),\n  'alpha_escape_keV': 8.79526763381691,\n  'color': array([0.9127, 0.9127, 0.7008])},\n {'elem': 'Pb',\n  'name': 'Lead',\n  'peaks_xy': array([[10.5503,  1.    ],\n         [12.6213,  0.8551],\n         [ 2.3712,  0.2299],\n         [14.7674,  0.1328],\n         [12.3062,  0.0575],\n         [ 9.1846,  0.0564],\n         [15.1726,  0.0373],\n         [ 1.8309,  0.0265],\n         [11.3457,  0.0177]]),\n  'alpha_escape_keV': 8.810275137568784,\n  'color': array([0.4, 0.4, 0.4])},\n {'elem': 'Br',\n  'name': 'Bromine',\n  'peaks_xy': array([[11.916 ,  1.    ],\n         [13.2966,  0.1603],\n         [ 1.5008,  0.046 ]]),\n  'alpha_escape_keV': 10.175957978989494,\n  'color': array([0.4, 0.3, 0. ])},\n {'elem': 'Sr',\n  'name': 'Strontium',\n  'peaks_xy': array([[14.1521,  1.    ],\n         [15.8329,  0.175 ],\n         [ 1.8309,  0.0553]]),\n  'alpha_escape_keV': 12.41207603801901,\n  'color': array([0.8618, 0.8618, 0.8618])},\n {'elem': 'Rh',\n  'name': 'Rhodium',\n  'peaks_xy': array([[20.2001,  1.    ],\n         [22.7214,  0.243 ],\n         [ 2.7014,  0.0815],\n         [23.1716,  0.0408]]),\n  'alpha_escape_keV': 18.460100050025016,\n  'color': array([0.6582, 0.6582, 0.6582])},\n {'elem': 'Ag',\n  'name': 'Silver',\n  'peaks_xy': array([[22.1511,  1.    ],\n         [24.9275,  0.259 ],\n         [ 2.9865,  0.0898],\n         [25.4527,  0.0452]]),\n  'alpha_escape_keV': 20.411075537768888,\n  'color': array([0.9811, 0.8168, 0.89  ])},\n {'elem': 'Cd',\n  'name': 'Cadmium',\n  'peaks_xy': array([[23.1716,  1.    ],\n         [23.0065,  0.5582],\n         [26.083 ,  0.2645],\n         [ 3.1366,  0.0922],\n         [26.6383,  0.048 ]]),\n  'alpha_escape_keV': 21.43158579289645,\n  'color': array([0.9326, 0.633 , 0.8487])},\n {'elem': 'Sn',\n  'name': 'Tin',\n  'peaks_xy': array([[25.2726,  1.    ],\n         [25.0475,  0.5393],\n         [28.4692,  0.2695],\n         [ 3.4367,  0.0961],\n         [ 3.6618,  0.0542],\n         [29.1146,  0.0533]]),\n  'alpha_escape_keV': 23.53263631815908,\n  'color': array([0.8539, 0.7446, 0.7215])}]\n\n\n\ndef extract_alpha_keVs(elem_ptrns=None): \n    \n    if elem_ptrns is None: \n        elem_ptrns = get_patterns()\n    \n    alpha_keVs = []\n    elements = []\n    alpha_list = []\n    \n    for i, p in enumerate(elem_ptrns):     \n        a_keV = p['peaks_xy'][0, 0] \n        alpha_keVs.append(a_keV)\n        \n        elem = p['elem']\n        elements.append(elem)\n        \n        alpha_list.append([elem, a_keV])\n         \n    return alpha_list\n\n\nalpha_list = extract_alpha_keVs()\n\n\n[a[1] for a in alpha_list]\n\n[0.3901950975487744,\n 0.5252626313156579,\n 0.6753376688344173,\n 0.8554277138569285,\n 1.0355177588794398,\n 1.2606303151575788,\n 1.485742871435718,\n 1.7408704352176088,\n 2.0110055027513756,\n 2.3111555777888944,\n 2.626313156578289,\n 3.3166583291645826,\n 3.691845922961481,\n 3.9319659829914957,\n 4.457228614307153,\n 4.502251125562782,\n 4.9524762381190595,\n 5.417708854427214,\n 5.897948974487244,\n 6.393196598299149,\n 6.9184592296148075,\n 7.473736868434218,\n 8.044022011005502,\n 8.629314657328665,\n 9.9799899949975,\n 10.53526763381691,\n 10.550275137568784,\n 11.915957978989494,\n 14.15207603801901,\n 20.200100050025014,\n 22.151075537768886,\n 23.171585792896447,\n 25.27263631815908]\n\n\n\nd.items()\n\ndict_items([('N', 0.3901950975487744)])\n\n\n\nalpha['elem']\n\narray(['N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'K',\n       'Ca', 'I', 'Ba', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu',\n       'Zn', 'Hg', 'As', 'Pb', 'Br', 'Sr', 'Rh', 'Ag', 'Cd', 'Sn'],\n      dtype='&lt;U8')\n\n\nLet’s color the markers on these matched instrument peaks red…\n\ny_hot = ds.read('hotmax_spectra')[4] \n\nmatch_idxs = peak_matches[:, 0]\nmatch_x = subpeak_keVs[match_idxs]\nmatch_y = y_hot[np.array(subpeak_idxs)[match_idxs]]\n\n\nsubpeak_idxs[]\n\n[95, 1981, 466, 735, 427, 329, 2108, 800, 2206, 1360, 152, 1522, 933]\n\n\n\nfrom maxrf4u import HotmaxAtlas\n\n\nhma = HotmaxAtlas('RP-T-1898-A-3689.datastack')\n\n\nax, ann_list = hma.plot_spectrum(4)\n\nax.scatter(match_x, match_y, facecolor='r', edgecolor='w', marker='X', s=100)\nax.set_title('Matching instrument peaks');\n\n..\n\n\nAnd note down for which peaks we now have an explanation:\n\nnp.set_printoptions(precision=4)\n\n\n\n\n[-0.028648044952708673,\n 18.895639680305266,\n 3.693998161871633,\n 6.393167513989552,\n 3.3026687762485896,\n 2.3193282687855556,\n 20.16996870528287,\n 7.0453831566946254,\n 21.153309212745903,\n 12.664471770769104,\n 0.5432949032655865,\n 14.289993834126363,\n 8.379916702537315]\n\n\n\nfor n in [0, 1, 6]: \n    explanation[n]['src'] = 'INSTR'\n\n\nexplanation\n\n[{'n': 0, 'keV': -0.028648044952708673, 'src': 'INSTR'},\n {'n': 1, 'keV': 18.895639680305266, 'src': 'INSTR'},\n {'n': 2, 'keV': 3.693998161871633, 'src': '????'},\n {'n': 3, 'keV': 6.393167513989552, 'src': '????'},\n {'n': 4, 'keV': 3.3026687762485896, 'src': '????'},\n {'n': 5, 'keV': 2.3193282687855556, 'src': '????'},\n {'n': 6, 'keV': 20.16996870528287, 'src': 'INSTR'},\n {'n': 7, 'keV': 7.0453831566946254, 'src': '????'},\n {'n': 8, 'keV': 21.153309212745903, 'src': '????'},\n {'n': 9, 'keV': 12.664471770769104, 'src': '????'},\n {'n': 10, 'keV': 0.5432949032655865, 'src': '????'},\n {'n': 11, 'keV': 14.289993834126363, 'src': '????'},\n {'n': 12, 'keV': 8.379916702537315, 'src': '????'}]\n\n\nNow that we matched the instrumental peaks, we need to explain the other remaining peaks following their sorting order (from large to small). This means that next we need to explain peak (2). For this, we need to consult the peak pattern atlas…\n\nnp.argwhere([p['src'] == '????' for p in explanation]).flatten()\n\narray([ 2,  3,  4,  5,  7,  8,  9, 10, 11, 12])",
    "crumbs": [
      "Solving the peak pattern puzzle"
    ]
  },
  {
    "objectID": "suzanna.html",
    "href": "suzanna.html",
    "title": "Meet Susanna",
    "section": "",
    "text": "Meet Susanna and the Elders. She is a very special drawing by Rembrandt in the collection of the Rijksmuseum in Amsterdam. While developing this code, I have spent an awful lot of time to reveal her secrets and those of x-ray fluorescence. Throughout this documentation we will look at the MA-XRF spectral image made by Leila Sauvage and her colleagues working in the paper conservation studio of the Rijksmuseum.\n\n\n\n\n\nSusanna and the Elders (c.1650-c.1655) Rembrandt van Rijn, Rijksmuseum Amsterdam RP-T-1898-A-3689\nIt seems to me that this drawing substantially has changed it’s appearance over time. There are indications that Rembrandt used white paint to cover parts of the drawing that he did not like, and drew new lines on top of this paint. Nowadays these areas with white paint have become translucent and no longer to hide the ink underneath.",
    "crumbs": [
      "Meet Susanna"
    ]
  },
  {
    "objectID": "hotmax.html",
    "href": "hotmax.html",
    "title": "Hotmax spectra",
    "section": "",
    "text": "A MA-XRF spectral image data cube contains typically a million spectra or so. Far too many to analyze them individually! Furthermore, most of these spectra have low signals and are rather noisy. An approach to overcome these computational problems is to base a further data analysis solely on the max spectrum. Such an approach is used e.g. by DataMuncher developed by Matthias Alfeld. As discussed above, the max spectrum essentially is an envelope function that provides a highly informative summary of all spectra. Different peaks in the max spectrum envelope can originate from from different spatial positions in the spectral image. Although this mathematical combination of spectral signals reduces computational analysis time, down the road it complicates our task of unmixing spectra and attribution of specific peak patterns to different chemical elements.\n\nLocating the hotmax pixels and spectra\nA more sophisticated approach is to locate for each peak in the max spectrum envelope which specific pixel spectrum is responsible for that specific peak. Loosely speaking, which pixels in the spectral image data cube are ‘hotmax’? Another way to explain this is to find the specific ‘hotmax’ spectra that touches the corresponding max spectrum peaks.\nA requisite step in the data analysis now is to find the hotmax pixels and spectra. Locating them takes a few minutes, and should be done once using the get_hotmax_spectra() function. The user is prompted to inspect and save the result in the datastack file.\n\nfrom maxrf4u import compute_hotmax_spectra\n\n\ncompute_hotmax_spectra('RP-T-1898-A-3689.datastack')\n\nStep 1/3: Reading hot max channel maps...\n[########################################] | 100% Completed | 112.39 s\nStep 2/3: Locating hot max pixels...\nStep 3/3: Ready with reading hot max spectra. \n\n\nWrite hotmax spectra, spots and peak indices to datastack file [y/n]?  y\n\n\n\nSaved hotmax data to: RP-T-1898-A-3689.datastack\n\n\n\n\n\n\n\n\n\nIn further analysis our stored hotmax spectra, spots and peak indexes can now be accessed from file using the DataStack.read(&lt;datapath&gt;) and DataStack.read_list(&lt;datapath&gt;) methods.\n\nfrom maxrf4u import DataStack, tree\n\n\ntree('RP-T-1898-A-3689.datastack')\n\nRP-T-1898-A-3689.datastack:\n\n/\n ├── compton_peak_energy (1,) float64\n ├── hotmax_baselines (22, 4096) float64\n ├── hotmax_noiselines (22, 4096) float64\n ├── hotmax_peak_idxs_flat (24,) int64\n ├── hotmax_peak_idxs_list (22, 3) int64\n ├── hotmax_peak_idxs_list_ (22, 3) int64\n ├── hotmax_peak_idxs_list__ (22, 3) int64\n ├── hotmax_spectra (22, 4096) float32\n ├── hotmax_spectra_ (22, 4096) float32\n ├── hotmax_spectra__ (22, 4096) float32\n ├── hotmax_spots (22, 2) int64\n ├── hotmax_spots_ (22, 2) int64\n ├── hotmax_spots__ (22, 2) int64\n ├── hotmax_subpeak_idxs_list (22, 15) int64\n ├── imvis_extent (4,) int64\n ├── imvis_reg (1692, 1592, 4) float32\n ├── imvis_reg_highres (4920, 4629, 4) float32\n ├── maxrf_cube (1692, 1592, 4096) float32\n ├── maxrf_energies (4096,) float64\n ├── maxrf_maxspectrum (4096,) float32\n ├── maxrf_sumspectrum (4096,) float64\n ├── nmf_gausscomponents (25, 4096) float32\n ├── nmf_peakmaps (25, 1692, 1592) float32\n └── test_list (3, 3) int64\n\n\n\nds = DataStack('RP-T-1898-A-3689.datastack')\n\nx_keVs = ds.read('maxrf_energies')\nhotmax_spectra = ds.read('hotmax_spectra')\nhotmax_spots = ds.read('hotmax_spots')\nhotmax_peak_idxs_list = ds.read_list('hotmax_peak_idxs_list')\n\nTo get an idea, let’s plot both the spatial (x, y) locations of the hotmax spots on the image of the drawing, and their corresponding hotmax spectra.\n\n\nCode\nimport matplotlib.pyplot as plt \nfrom maxrf4u.peakmaps import _add_hotlines_ticklabels\n\n\n\nfig, ax = plt.subplots()\nfor i, s in enumerate(hotmax_spectra): \n    ax.plot(x_keVs, s + 10*i)\n\n\n\n\n\n\n\n\n\n\nCode\ny, x = hotmax_spots.T\n\nim = ds.read('imvis_reg_highres')\nextent = ds.read('imvis_extent')\n\nfig = plt.figure(figsize=[7, 8], constrained_layout=True)\ngrid = plt.GridSpec(22, 2, figure=fig)\n\nax = fig.add_subplot(grid[0:22, 0])\nax.imshow(im, extent=extent)\nax.scatter(x, y, alpha=0.4, color='r', marker='s');\n\nax.set_title('Hotmax spots')\n\naxs = []\nfor n, spectrum in enumerate(hotmax_spectra): \n    \n    ax1 = fig.add_subplot(grid[n, 1])\n    axs.append(ax1)\n    \n    ax1.plot(x_keVs, spectrum)\n    \n    peak_idxs = hotmax_peak_idxs_list[n]\n    ax1.scatter(x_keVs[peak_idxs], spectrum[peak_idxs], alpha=0.4, color='r', marker='s')\n    \n    ax1.set_xlim([-1, 25])\n    ax1.set_yticks([])\n    # label \n    ax1.text(-0.015, 0.5, f'{n}', c='C0', ha='right', va='center', transform=ax1.transAxes)\n    \n#axs[0].get_shared_x_axes().join(*axs)\n\n# hack to suppress ticklabels in upper plot \n# https://stackoverflow.com/questions/4209467 \n# matplotlib-share-x-axis-but-dont-show-x-axis-tick-labels-for-both-just-one\nfor ax1 in axs[0:-1]: \n    plt.setp(ax1.get_xticklabels(), visible=False) \n    \naxs[0].set_title('Hotmax spectra')\naxs[-1].set_xlabel('energy (keV)')\n\n\nfor i, xy in enumerate(zip(x, y)): \n    # hack to avoid overlapping labels \n    xytext = [0, 6]\n    if i == 6: \n        xytext = [0, -12]\n    if i == 16: \n        xytext = [0, -12]\n    ax.annotate(f'[{i}]', xy, xytext=xytext, color='C0', textcoords='offset points', ha='center')\n\n\n\n\n\n\n\n\n\nNow let’s pick one of the 22 hotmax spectra and take a closer look. Each hotmax spectrum has one or more peaks (square red marker) that correspond to specific peaks in the the max spectrum envelope.\n\nimport matplotlib.pyplot as plt\n\n\n\nCode\nn = 12 \n\nds = DataStack('RP-T-1898-A-3689.datastack')\n\nhotmax_spectra = ds.read('hotmax_spectra')\n\nhotmax_peak_idxs_list = ds.read_list('hotmax_peak_idxs_list')\nx_keVs = ds.read('maxrf_energies')\ny_max = ds.read('maxrf_maxspectrum') \n\nspectrum = hotmax_spectra[n]\nidxs = hotmax_peak_idxs_list[n] \npeaks_x = x_keVs[idxs]\npeaks_y = spectrum[idxs]\n\nfig, ax = plt.subplots(figsize=[7, 3])\n\nax.plot(x_keVs, spectrum, label=f'hotmax spectrum #{n}')\nax.scatter(peaks_x, peaks_y, edgecolor='r', \n           marker='s', facecolor='w', label=f'hotmax peak(s)')\nax.fill_between(x_keVs, y_max, color='r', alpha=0.2, label='max spectrum')\nax.set_xlabel('energy [keV]')\nax.set_ylabel('Intensity [#counts]')\nax.set_ylim(-1, 1.1*spectrum.max())\nax.set_xlim(-1, 25)\nax.grid()\nax.legend();\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\nEach spectrum consists of a a slowly varying baseline, the so-called the continuum ridge, with peaks added on top. Some of these peaks are caused by x-ray fluorescence of specific chemical elements. Other peaks are just noise. The difficulty with these kind of spectra is that the noise level varies with the signal according to Poisson statistics. The variance of noise is linearly proportional to the signal level. For this reason, we observe more noise on top of the continuum ridge.\nIn order to distinguish significant peaks from noise it is possible to estimate a baseline with a noise envelope for the hotmax spectra with the compute_hotmax_noise()function. The algorithm used in estimating the baseline function is the rolling ball filter. In accordance with Poisson statistics, the noise level for the continuum is estimated as a square root function of the baseline level.\n\nfrom maxrf4u import compute_hotmax_noise\n\n\ncompute_hotmax_noise('RP-T-1898-A-3689.datastack')\n\nReady computing 22 noise envelopes.                           \n\n\n\nWrite hotmax baselines and noiselines to datastack file [y/n]?  y\n\n\n\nSaved hotmax noise data to: RP-T-1898-A-3689.datastack\n\n\nGiven the computed noise envelope for each spectrum we are now ready to locate potentially significant peaks with the compute_subpeaks() function and save their locations to the datastack file.\n\nfrom maxrf4u import compute_subpeaks\n\n\ncompute_subpeaks('RP-T-1898-A-3689.datastack');\n\nWrite hotmax baselines and noiselines to datastack file [y/n]?  y\n\n\n\nSaved hotmax subpeak indexes list to: RP-T-1898-A-3689.datastack\n\n\nWe can now create a HotmaxAtlas object to plot all spectra with their noise envelopes and sub peaks with the HotmaxAtlas.plot_spectra() method.\n\nfrom maxrf4u import HotmaxAtlas\n\n\nhma = HotmaxAtlas('RP-T-1898-A-3689.datastack')\nhma.plot_spectra()\n\n\n\n\n\n\n\n\nOr we can plot a single spectrum with HotmaxAtlas.plot_spectrum(&lt;nr&gt;) method to inspect a specific hotmax spectrum.\n\nax, plabels = hma.plot_spectrum(12, legend=True)\n\n\n\n\n\n\n\n\nEach specific chemical element present is known to cause a specific peak pattern. Now we need to solve the inverse problem, which I call ‘the peak pattern puzzle’. Given a spectrum, which combination of elements is likely to have caused the combination of peaks we find in the spectrum? This is the topic of the next section…\n\n\nFUNCTIONS\n\nsource\n\ncompute_subpeaks\n\n compute_subpeaks (datastack_file, prominence=0.2, auto_write=False)\n\n*Find subpeaks in hotmax spectrum that exceed the noise envelope.\nWrites result to datas\nReturns: list of hotmax sub peak indices*\n\nsource\n\n\ncompute_hotmax_noise\n\n compute_hotmax_noise (datastack_file, radius=200, alpha=0.6, beta=0.1,\n                       auto_write=False)\n\nUtility function to get baselines and noiselines from hotmax spectra in datastack_file*.\nUse once to compute base noise envelopes. Ask user confirmation for saving result to datastack file.*\n\nsource\n\n\ncompute_hotmax_spectra\n\n compute_hotmax_spectra (datastack_file, prominence=0.35,\n                         auto_write=False)\n\nCollect hotmax pixels and corresponding spectra from datastack_file*.\nAsk user confirmation for saving result to datastack file.*\n\nsource\n\n\nHotmaxAtlas\n\n HotmaxAtlas (datastack_file, prominence=0.2)\n\nInitialize self. See help(type(self)) for accurate signature.",
    "crumbs": [
      "Hotmax spectra"
    ]
  },
  {
    "objectID": "interactive-plotting.html",
    "href": "interactive-plotting.html",
    "title": "About interactive visualization using cloud storage",
    "section": "",
    "text": "The whole point of doing all this is of course to be able to communicate the results of data processing in as rich a manner as possible. We have saved the calculated element maps in our datastack file. With the multi_plot() function one can create an overview plot with just a few lines of of code.\nCode\nimport os \nimport numpy as np \nimport matplotlib.pyplot as plt \n\nfrom maxrf4u import DataStack, multi_plot \nimport skimage.exposure as ske\nCode\nos.chdir('/home/frank/Work/Projecten/DoRe/viz/raw_nmf')\ndatastack_file = 'RP-T-1898-A-3689.datastack' \nds = DataStack(datastack_file)\n\nelements = ds.read('nmf_elements')\nelement_maps = ds.read('nmf_elementmaps')\nelement_maps_histeq = [ske.equalize_hist(m) for m in element_maps]\n\nfig, axs = multi_plot(*element_maps_histeq, titles=elements)\nfig.suptitle('histogram equalized element maps')\nplt.tight_layout()\n\n\n..\nNow I would like to share and explore this result with my colleagues and the rest of the world. Of course, one could save this plot in a low resolution overview image and share by email, or perhaps create a zip folder with high resolution images and send by Wetransfer. Rather unsatisfactory, clumsy, inefficient. In my experience, when exploring data each new thought requires yet another view of the same data. In some cases this is just a matter of zooming in to a specific location on the map, in other cases one might need to adjust contrast, mark locations etcetera. All of this is easy when one knows how to use Python and is sitting behind the same computer. However, I am aware that most of my colleagues can not program Python, and have other problems in life that they would like to solve first.\nIn the scientific Python community the need for interactive web based data visualization has since long been well understood. In these last years a rich ecosystem of open source web visualization tools has been developed. Two important Python packages that allow easy creation of interactive web dashboards are ipywidgets and ipyleaflet. My code here is makes use of these packages.\nOf course, one can only create web visualizations if one has the possibility to directly publish content on the web. Github offers free webhosting for nerds. These documentation pages you are reading are published via github. However, github is a version control system for code and not suitable to publish large amounts of image data. Better suited is cloud storage. In my case I acquired cloud storage from backblaze.com. The price for storing files is very cheap: $0.005 GB/Month. Cloud storage is organized in so-called buckets. Files within those buckets can be loaded into web pages. A convenient way to upload files to a web bucket is to mount the bucket into the computer’s file system using a command line tool called rclone.\nEnough talk for now. Below I will show you how to create an interactive visualization. Starting point is the histogram equalized element maps for the eleven elements.\nCode\nfrom maxrf4u import DataStack, multi_plot \nimport skimage.exposure as ske\nCode\ndatastack_file = 'RP-T-1898-A-3689.datastack' \nds = DataStack(datastack_file)\n\nelements = ds.read('nmf_elements')\nelement_maps = ds.read('nmf_elementmaps')\nelement_maps_histeq = [ske.equalize_hist(m) for m in element_maps] # improve contrast\nLet’s start by preparing standard filenames for the jpeg images that will be used in the visualization using the make_filenames() function.\nfrom maxrf4u import make_filenames\nobjnr = 'RP-T-1898-A-3689' \nviztype = 'histeq_elementmap' \next = 'jpg'\n\nfilenames = make_filenames(objnr, viztype, elements, ext)\nfilenames\n\n['RP-T-1898-A-3689_histeq_elementmap_S.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Cl.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_K.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Ca.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Ba.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Ti.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Mn.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Fe.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Cu.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Zn.jpg',\n 'RP-T-1898-A-3689_histeq_elementmap_Pb.jpg']\nA next step is to create an standard image upload directory object and upload the images to the cloud storage. This is done with the UploadDir() function and .imsave() method.\nfrom maxrf4u import UploadDir\nbucket_url = 'https://f002.backblazeb2.com/file/dore-viz' \nmount_dir = '/media/frank/b2/dore-viz/' \n\nuplink = UploadDir(mount_dir, objnr, bucket_url, subdir='images')\n\nCreated online images folder: https://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images\nimg_urls = uplink.imsave(element_maps_histeq, filenames)\n\nSaving 11 images to folder: https://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images\n\n\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_S.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Cl.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_K.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Ca.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Ba.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Ti.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Mn.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Fe.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Cu.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Zn.jpg\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/images/RP-T-1898-A-3689_histeq_elementmap_Pb.jpg\nNow that we have these images available online, we can build the interactive ‘gridbox’ visualization with the make_gridbox_widget() function, and save the the result as an html webpage with the .export_interactive_html() method.\nfrom maxrf4u import make_gridbox_widget\ngridbox = make_gridbox_widget(img_urls, titles=elements)\nuplink.export_interactive_html(gridbox, viztype='histeq_elementmap');\n\nSaving interactive html to cloud storage...\nClick link to load the interactive visualization (opens a separate page).\n\nhttps://f002.backblazeb2.com/file/dore-viz/RP-T-1898-A-3689/html/RP-T-1898-A-3689_histeq_elementmap.html\nClick link to load the interactive visualization (opens a separate page).",
    "crumbs": [
      "About interactive visualization using cloud storage"
    ]
  },
  {
    "objectID": "interactive-plotting.html#functions",
    "href": "interactive-plotting.html#functions",
    "title": "About interactive visualization using cloud storage",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nexport_element_maps\n\n export_element_maps (datastack_file, output_dir=None, histeq=True)\n\nSave element maps as separate png images.\n\nsource\n\n\nmake_gridbox_widget\n\n make_gridbox_widget (img_urls, titles, shape=None)\n\nCreates multi-image interactive synchronized viewer.\n\nsource\n\n\nmake_filenames\n\n make_filenames (objnr, viztype, titles, ext)\n\n*Creates standard filenames.\nReturns: filenames*\n\nsource\n\n\nUploadDir\n\n UploadDir (mount_dir, objnr, bucket_url, subdir='images')\n\nCreates a standard upload (image) directory object.",
    "crumbs": [
      "About interactive visualization using cloud storage"
    ]
  },
  {
    "objectID": "calibration.html",
    "href": "calibration.html",
    "title": "Calibration",
    "section": "",
    "text": "Inconveniently, MA-XRF data does not always include information about the energy calibration of the spectra. Although it is clear that the channel energies will roughly range between zero and the tube voltage, we need more precise numbers for the upcoming calculations. Thus, a very first step in the data analysis is to obtain a precise energy calibration in keV units (kilo-electron-Volt) for a given dataset. Fortunately, XRF spectra, (at least for drawings), typically have two clearly recognizable features that allow for energy calibration of the detector channels.",
    "crumbs": [
      "Calibration"
    ]
  },
  {
    "objectID": "calibration.html#two-steps",
    "href": "calibration.html#two-steps",
    "title": "Calibration",
    "section": "Two steps",
    "text": "Two steps\nThe automatic precise energy calibration is done in two steps.\nIn the first step the dominant broad Compton peak is observed in the sum spectrum. The position of this peak can not be used for the calibration directly due to an unknown (detector angle specific) Compton shift, but it serves as a landmark. Right next to the Compton peak a small peak is found. In our lab an x-ray tube with a Rhodium anode is used. This peak can now be attributed to elastic scattering of the strong Rhodium K-alpha emission peak present in the x-ray tube spectrum at 20.21 keV.\nIn the second step of the calibration process the iron K-alpha emission peak is located in the max spectrum. Essentially all artifacts like paper contain iron, with a known strong emission K-alpha line at 6.403 keV.\nAs a first requisite step in any further data analysis the function calibrate() is called. The user is prompted to inspect and save the result.\n\nfrom maxrf4u import calibrate, DataStack\n\n\nx_keVs = calibrate('RP-T-1898-A-3689.datastack', tube_keV=40)\n\n\n\n\n\n\n\n\nWrite instrument energy calibration to datastack file [y/n]?  y\n\n\n\nWriting channel energies (keV) to: RP-T-1898-A-3689.datastack\nAlso writing instrument Compton anode peak energy (keV) to: RP-T-1898-A-3689.datastack\n\n\nIn further analysis our stored energy calibration can now be accessed using the .read('maxrf_energies') method which returns an array with 4096 energy values.\n\nds = DataStack('RP-T-1898-A-3689.datastack')\nx_keVs = ds.read('maxrf_energies')\n\nprint('Energies: ', x_keVs)\nprint(f'Number of energy channels: {len(x_keVs)}')\n\nEnergies:  [-0.98188629 -0.97185221 -0.96181812 ... 40.08763102 40.09766511\n 40.1076992 ]\nNumber of energy channels: 4096\n\n\nNow that we have an energy calibration, we can move to the next step in our data analysis.",
    "crumbs": [
      "Calibration"
    ]
  },
  {
    "objectID": "calibration.html#functions",
    "href": "calibration.html#functions",
    "title": "Calibration",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\ncompton_shift\n\n compton_shift (keV_in, theta)\n\n*Compute Compton shift for photon energies keV_in and scatter angle theta.\nAssuming single scattering.\nReturns: keV_out*\n\nsource\n\n\nfind_instrument_peaks\n\n find_instrument_peaks (y_sum, prominence=0.1, tube_keV=40)\n\n*Locate key instrument peaks:\n      1) left hand sensor peak index  \n      2) anode Compton peak index  \n      3) right hand (rhodium) anode Ka peak index  \n\n      in sum spectrum `y_sum`. \nAssumes anode material is rhodium, and Compton peak energy is first peak below (uncalibrated) 20 keV, based on tube keV.\nReturns: [left_peak_i, compton_peak_i, right_peak_i]*\n\nsource\n\n\ndetector_angle\n\n detector_angle (keV0, keV1)\n\n*Calculate detector scatter angle theta (degrees)\nFrom Compton peak energy keV0 and anode energy keV1, assuming a single scattering event.\nReturns: theta (degrees)*\n\nsource\n\n\ncalibrate\n\n calibrate (datastack_file, anode='Rh', prominence=0.1, tube_keV=40,\n            auto_write=False)\n\n*Automatic two step energy energy calibration.\nIn step 1 a preliminary calibration is done assuming that the\nsensor peak is located at 0 keV and the Rhodium anode Ka peak is next to it’s high and broad Compton scattering peak in the sum spectrum.\nThis preliminary calibration the enables the identification of Fe_Ka peak in the max spectrum and a second precise calibration.\nAsks user confirmation to store energy calibration in datastack file.\nReturns: x_keVs*",
    "crumbs": [
      "Calibration"
    ]
  }
]