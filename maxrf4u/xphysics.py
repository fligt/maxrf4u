# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/90_xphysics.ipynb (unless otherwise specified).

__all__ = ['gaussian_convolve', 'ElementLines', 'xrf_spectrum']

# Cell

import numpy as np
import xraydb

def gaussian_convolve(peak_energies, peak_intensities, x_keVs=None, std=0.01):
    '''Convolves line spectrum defined by `peak_energies` and `peak_intensities`

    with a Gaussian peak shape. '''

    if x_keVs is None:
        x_keVs = np.linspace(0, 40, 10000)

    y_spectrum = np.zeros_like(x_keVs)

    for peak_energy, peak_intensity in zip(peak_energies, peak_intensities):

        y_spectrum += peak_intensity * np.exp(-(1 / std) * (x_keVs - peak_energy)**2)

    return x_keVs, y_spectrum


class ElementLines():
    '''Computes fluorescence emission line energies and intensities for `element`.

    '''

    def __init__(self, element, excitation_energy_keV):

        excitation_energy = 1000 * excitation_energy_keV

        lines = xraydb.xray_lines(element, excitation_energy=excitation_energy)

        peak_names = []
        peak_labels = []
        peak_energies = []
        peak_intensities = []

        for name, line in lines.items():

            peak_names.append(name)

            # intensities (a.k.a. transition probablities) sum up to unity within each level
            energy, intensity, initial_level, final_level = line
            peak_energies.append(energy)
            label = f'{element}_{initial_level}{final_level}'
            peak_labels.append(label)

            # get corresponding edge properties
            edge = initial_level # IUPAC notation!  e.g. 'L1', not 'La'
            edge_energy, fluo_yield, jump_ratio = xraydb.xray_edge(element, edge)
            jump_coeff = (jump_ratio - 1) / jump_ratio # see Volker
            #print(f'{name}: {energy}; jump_coeff: {jump_coeff:.03f}; fluo_yield: {fluo_yield}')

            # multiplying edge jump coefficient, intensity and fluorescence yield...
            peak_intensity = jump_coeff * intensity * fluo_yield
            peak_intensities.append(peak_intensity)

        # determine sorting according to peak_intensities...
        self.peak_intensities = np.array(peak_intensities)
        indices = np.argsort(self.peak_intensities)[::-1]

        # sort
        self.peak_intensities = self.peak_intensities[indices]
        self.peak_energies = np.array(peak_energies)[indices] / 1000
        self.peak_names = np.array(peak_names)[indices]
        self.peak_labels = np.array(peak_labels)[indices]


def xrf_spectrum(element, excitation_energy_keV, normalize=True, x_keVs=None, std=0.01):
    '''Compute simple excitation spectrum (no matrix effects). '''

    el = ElementLines(element, excitation_energy_keV)

    x_keVs, y_spectrum = gaussian_convolve(el.peak_energies, el.peak_intensities, x_keVs=x_keVs, std=std)

    return x_keVs, y_spectrum
