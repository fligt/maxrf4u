# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/90_xphysics.ipynb (unless otherwise specified).

__all__ = ['gaussian_convolve', 'ElementLines', 'get_element_spectrum', 'get_element_spectra']

# Cell

import numpy as np
import xraydb

def gaussian_convolve(peak_energies, peak_intensities, x_keVs=None, std=0.01):
    '''Convolves line spectrum defined by `peak_energies` and `peak_intensities`

    with a Gaussian peak shape. '''

    if x_keVs is None:
        x_keVs = np.linspace(0, 40, 10000)

    y_spectrum = np.zeros_like(x_keVs)

    for peak_energy, peak_intensity in zip(peak_energies, peak_intensities):

        y_spectrum += peak_intensity * np.exp(-(1 / std) * (x_keVs - peak_energy)**2)

    return x_keVs, y_spectrum


class ElementLines():
    '''Computes fluorescence emission line energies and intensities for `element`.

    '''

    def __init__(self, element, excitation_energy_keV):

        excitation_energy = 1000 * excitation_energy_keV

        lines = xraydb.xray_lines(element, excitation_energy=excitation_energy)

        peak_names = []
        peak_labels = []
        peak_energies = []
        peak_intensities = []

        for name, line in lines.items():

            peak_names.append(name)

            # intensities (a.k.a. transition probablities) sum up to unity within each level
            energy, intensity, initial_level, final_level = line
            peak_energies.append(energy)
            label = f'{element}_{initial_level}{final_level}'
            peak_labels.append(label)

            # get corresponding edge properties
            edge = initial_level # IUPAC notation!  e.g. 'L1', not 'La'
            edge_energy, fluo_yield, jump_ratio = xraydb.xray_edge(element, edge)
            jump_coeff = (jump_ratio - 1) / jump_ratio # see Volker
            #print(f'{name}: {energy}; jump_coeff: {jump_coeff:.03f}; fluo_yield: {fluo_yield}')

            # multiplying edge jump coefficient, intensity and fluorescence yield...
            peak_intensity = jump_coeff * intensity * fluo_yield
            peak_intensities.append(peak_intensity)

        # determine sorting according to peak_intensities...
        self.peak_intensities = np.array(peak_intensities)
        indices = np.argsort(self.peak_intensities)[::-1]

        # sort
        self.peak_intensities = self.peak_intensities[indices]
        self.peak_energies = np.array(peak_energies)[indices] / 1000
        self.peak_names = np.array(peak_names)[indices]
        self.peak_labels = np.array(peak_labels)[indices]


def get_element_spectrum(element, excitation_energy_keV, normalize=True, x_keVs=None, std=0.01):
    '''Compute simple excitation spectrum (no matrix effects).

    Based on xraydb.

    Returns: y_spectrum'''

    el = ElementLines(element, excitation_energy_keV)

    x, y_spectrum = gaussian_convolve(el.peak_energies, el.peak_intensities, x_keVs=x_keVs, std=std)

    if normalize:
        y_spectrum = y_spectrum / y_spectrum.max()

    if x_keVs is None:

        return x, y_spectrum

    else:
        return y_spectrum


def get_element_spectra(elements, x_keVs, excitation_energy_keV):
    '''Compute theoretical emission spectrum for multiple elements.

    Sorts elements according to largest (alpha) peak. Based on xraydb.

    Returns: elements, element_spectra
    '''

    n_channels = len(x_keVs)
    n_elements = len(elements)

    element_spectra = np.zeros([n_elements, n_channels])

    for i, elem in enumerate(elements):
        element_spectra[i] = get_element_spectrum(elem, excitation_energy_keV, x_keVs=x_keVs)

        # normalize
        element_spectra[i] = element_spectra[i] / element_spectra[i].max()


    # sort according to energy of largest (=alpha) peak
    alpha_idxs = np.argmax(element_spectra, axis=1)
    alpha_order = np.argsort(alpha_idxs)

    elements = [elements[i] for i in alpha_order]
    element_spectra = element_spectra[alpha_order]

    return elements, element_spectra
