# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/30_spatial-verus-spectral.ipynb (unless otherwise specified).

__all__ = ['get_slices', 'get_peakmaps', 'plot_peak_slices', 'warp']

# Cell

import scipy.signal as ssg
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import cv2


def get_slices(x_calib, y_max, prominence=0.5, rel_height=0.2):
    '''Returns: *peaks_xy*, *slices*'''

    # peak positions and properties
    peak_indices, shapes_dict = ssg.find_peaks(y_max, prominence=prominence)
    peaks_x, peaks_y = x_calib[peak_indices], y_max[peak_indices]
    ip_widths, heights, left_ips, right_ips = ssg.peak_widths(y_max, peak_indices, rel_height=rel_height)

    # estimate peak bases 2 x 2 x width at rel_height 0.2
    dx = x_calib[1] - x_calib[0]
    left_bases = peaks_x -  2 * dx * ip_widths
    right_bases = peaks_x +  2 * dx * ip_widths

    # find nearest index positions
    left_bases_idx = np.array([np.argmin((x_calib - lb)**2) for lb in left_bases])
    right_bases_idx = np.array([np.argmin((x_calib - rb)**2) for rb in right_bases])

    # combine
    peaks_xy = np.c_[peaks_x, peaks_y]
    slices = np.c_[left_bases_idx, peak_indices, right_bases_idx]

    return peaks_xy, slices



def get_peakmaps(arr, x_calib, y_max, prominence=0.5, rel_height=0.2, norm=True):
    '''Integrate peak slices into peak maps and keV maps.

    Returns: peak_maps, keV_maps'''

    peaks_xy, slices = get_slices(x_calib, y_max, prominence=prominence, rel_height=rel_height)

    peak_maps = []
    keV_maps = []

    for i, [si, sj, sk] in enumerate(slices):

        print(f'{i}/{len(slices)}', end='\r')

        peak_slice = arr[:,:,si:sk+1].compute()
        d = sk - si

        peak_map = np.sum(peak_slice, axis=2) / d - (peak_slice[:,:,0] + peak_slice[:,:,-1]) / 2

        if norm:
            peak_map = peak_map / peak_map.max()
            # no clipping to study better the low signal noise
            # peak_map = np.clip(peak_map, a_min=0, a_max=1)

        keV_idx_map = si + np.argmax(peak_slice, axis=2)
        keV_map = x_calib[keV_idx_map]

        peak_maps.append(peak_map)
        keV_maps.append(keV_map)

    return peak_maps, keV_maps



def plot_peak_slices(x_calib, y_max, ax=None, prominence=0.5, rel_height=0.2,
                     grid=False, labels='simple', figsize=[8, 5]):
    '''Utility function to plot the results of get_slices()'''

    peaks_xy, slices = get_slices(x_calib, y_max, prominence=prominence, rel_height=rel_height)
    zero = np.zeros_like(x_calib)

    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)
    else:
        fig = ax.get_figure()

    ax.plot(x_calib, y_max)

    if labels is 'simple':
        peak_labels = [f'[{i}]' for i in range(len(peaks_xy))]
    elif labels is 'full':
        peak_labels = [f'[{i}]\n{keV:.03f}keV' for i, [keV, _] in enumerate(peaks_xy)]
    else:
        assert False, 'Option labels=  can be "simple" or "full"'

    [ax.annotate(s, xy, xytext=(0, 10), ha='center', textcoords='offset points') for s, xy in zip(peak_labels, peaks_xy)]

    ax.scatter(*peaks_xy.T)
    if grid:
        ax.grid()

    # colorize peak slices
    n_slices = len(slices)
    colors = cm.tab20(np.arange(n_slices) % 20)


    [ax.fill_between(x_calib, zero, y_max, alpha=0.6, color=color,
                     where=np.r_[np.zeros(i), np.ones(k - i), np.zeros(len(x_calib) - k)])
     for [i, j, k], color in zip(slices, colors)];

    # expand to avoid label clipping
    y0, y1 = ax.get_ylim()
    ax.set_ylim([y0, 1.1 * y1])

    return fig, ax


def warp(im_src, im_dst, pts_src, pts_dst, keep_scale=True, rgba=True, alpha_color=[1, 0, 0]):
    '''Opencv based homographic registration. Can return transparent overlay (rgba).

    Returns: *im_warped*, *extent* '''

    src_h, src_w = im_src.shape[0:2]
    dst_h, dst_w = im_dst.shape[0:2]

    if keep_scale:
        scale = src_h / dst_h
    else:
        scale = 1

    # calculate homography
    hom, status = cv2.findHomography(pts_src, scale * pts_dst)

    # Size is nearest integer scaled (width,height) of im_dst
    size = round(scale * dst_w), round(scale * dst_h)

    # warp im_src onto destination
    im_warped = cv2.warpPerspective(im_src, hom, size)

    # warp white onto destination to create mask
    mask_src = np.ones([src_h, src_w])
    mask_warped = cv2.warpPerspective(mask_src, hom, size)

    # calculate extent for plotting
    h, w = im_dst.shape[0:2]
    extent =  (0, w, h, 0)

    # convert into rgba image
    if rgba is True:
        im_rgba = np.ones([h, w, 4])

        # for single channel image
        if len(im_src.shape) == 2:
            # colorize
            im_rgba[:,:,0:3] = alpha_color[0:3]
            #  make alpha layer
            im_rgba[:,:,3] = im_warped

        # otherwise assume image is rgb
        elif len(im_warped.shape) == 3:

            # rgb channels
            im_rgba[:,:,0:3] = im_warped[:,:,0:3]
            # alpha channels
            im_rgba[:,:,3] = mask_warped

        im_warped = im_rgba

    return im_warped, extent