# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/30_spatial-verus-spectral.ipynb (unless otherwise specified).

__all__ = ['get_slices', 'get_peakmaps', 'plot_peak_slices']

# Cell

import scipy.signal as ssg
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm


def get_slices(x_calib, y_max, prominence=0.5, rel_height=0.2):
    '''Returns: *peaks_xy*, *slices*'''

    # peak positions and properties
    peak_indices, shapes_dict = ssg.find_peaks(y_max, prominence=prominence)
    peaks_x, peaks_y = x_calib[peak_indices], y_max[peak_indices]
    ip_widths, heights, left_ips, right_ips = ssg.peak_widths(y_max, peak_indices, rel_height=rel_height)

    # estimate peak bases 2 x 2 x width at rel_height 0.2
    dx = x_calib[1] - x_calib[0]
    left_bases = peaks_x -  2 * dx * ip_widths
    right_bases = peaks_x +  2 * dx * ip_widths

    # find nearest index positions
    left_bases_idx = np.array([np.argmin((x_calib - lb)**2) for lb in left_bases])
    right_bases_idx = np.array([np.argmin((x_calib - rb)**2) for rb in right_bases])

    # combine
    peaks_xy = np.c_[peaks_x, peaks_y]
    slices = np.c_[left_bases_idx, peak_indices, right_bases_idx]

    return peaks_xy, slices



def get_peakmaps(arr, x_calib, y_max, prominence=0.5, rel_height=0.2, norm=True):
    '''Integrate peak slices into peak maps and keV maps.

    Returns: peak_maps, keV_maps'''

    peaks_xy, slices = get_slices(x_calib, y_max, prominence=prominence, rel_height=rel_height)

    peak_maps = []
    keV_maps = []

    for i, [si, sj, sk] in enumerate(slices):

        print(f'{i}/{len(slices)}', end='\r')

        peak_slice = arr[:,:,si:sk+1].compute()
        d = sk - si

        peak_map = np.sum(peak_slice, axis=2) / d - (peak_slice[:,:,0] + peak_slice[:,:,-1]) / 2

        if norm:
            peak_map = peak_map / peak_map.max()
            # no clipping to study better the low signal noise
            # peak_map = np.clip(peak_map, a_min=0, a_max=1)

        keV_idx_map = si + np.argmax(peak_slice, axis=2)
        keV_map = x_calib[keV_idx_map]

        peak_maps.append(peak_map)
        keV_maps.append(keV_map)

    return peak_maps, keV_maps



def plot_peak_slices(x_calib, y_max, ax=None, prominence=0.5, rel_height=0.2,
                     grid=False, labels='simple', figsize=[8, 5]):
    '''Utility function to plot the results of get_slices()'''

    peaks_xy, slices = get_slices(x_calib, y_max, prominence=prominence, rel_height=rel_height)
    zero = np.zeros_like(x_calib)

    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)
    else:
        fig = ax.get_figure()

    ax.plot(x_calib, y_max)

    if labels is 'simple':
        peak_labels = [f'[{i}]' for i in range(len(peaks_xy))]
    elif labels is 'full':
        peak_labels = [f'[{i}]\n{keV:.03f}keV' for i, [keV, _] in enumerate(peaks_xy)]
    else:
        assert False, 'Option labels=  can be "simple" or "full"'

    [ax.annotate(s, xy, xytext=(0, 10), ha='center', textcoords='offset points') for s, xy in zip(peak_labels, peaks_xy)]

    ax.scatter(*peaks_xy.T)
    if grid:
        ax.grid()

    # colorize peak slices
    n_slices = len(slices)
    colors = cm.tab20(np.arange(n_slices) % 20)


    [ax.fill_between(x_calib, zero, y_max, alpha=0.6, color=color,
                     where=np.r_[np.zeros(i), np.ones(k - i), np.zeros(len(x_calib) - k)])
     for [i, j, k], color in zip(slices, colors)];

    # expand to avoid label clipping
    y0, y1 = ax.get_ylim()
    ax.set_ylim([y0, 1.1 * y1])

    return fig, ax
