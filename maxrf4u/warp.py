# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/30_spatial-verus-spectral.ipynb (unless otherwise specified).

__all__ = ['img_to_url', 'mark_corners', 'on_marker_move', 'extract_corner_points', 'ImageRegistrationHelper', 'warp']

# Cell

from IPython.display import display
import ipyleaflet as ipl
from ipywidgets import Text, HTML, Layout, HBox, VBox
import ipywidgets
from ipyleaflet import Map, ImageOverlay, basemap_to_tiles, Marker, WidgetControl

import io
import matplotlib.pyplot as plt
import numpy as np
import base64
import skimage.transform as skt

import numpy as np
import cv2


def img_to_url(img_data, max_width=None):
    '''Filename or numpy array *img_data* is transformed into base64 encoded url string.

    To compress image specify thumbnail `max_width`.

    Returns: url_string, shape'''

    try:
        img = plt.imread(img_data) # if img_data is an image file path
    except:
        img = img_data # assuming img_data is an image like numpy array

    shape = img.shape[0:2] # height and width only
    h, w = shape

    # rescaling image if width > max_width
    if max_width is not None:
        if w > max_width:
            scale = max_width / w
            img = skt.rescale(img, scale, multichannel=True)


    buff = io.BytesIO();
    plt.imsave(buff, img, format='png')
    plt.close()

    base64_string = base64.b64encode(buff.getvalue()).decode("ascii")
    url_string = f'data:image/png;base64,{base64_string}'

    return url_string, shape


def mark_corners(map_, img_shape):

    h, w = img_shape[0:2]

    corners = [[h, 0], [h, w], [0, w], [0, 0]]
    colors = ['red', 'green', 'blue', 'orange']
    labels = ['top left', 'top right', 'bottom right', 'bottom left']

    markers = []

    for location, color, label in zip(corners, colors, labels):
        icon = ipl.AwesomeIcon(name='circle-o', marker_color=color)
        marker = Marker(location=location, draggable=True, title=f'Drag me to {label} landmark', icon=icon)
        markers.append(marker)
        map_.add(marker)

    return markers


# callback
def on_marker_move(change):

    textbox.value = extract_corner_points(src_markers, src_shape, dst_markers, dst_shape, return_text=True)



def extract_corner_points(src_markers, src_shape, dst_markers, dst_shape, return_text=False):
    '''Flip coordinates to make top of image zero.

    Returns: pts_string
    '''

    src_pts = []
    h, w = src_shape
    for marker in src_markers:
        y, x = marker.location
        xy_flip = [ x - 0.5, h - y - 0.5]
        src_pts.append(xy_flip)

    dst_pts = []
    h, w = dst_shape
    for marker in dst_markers:
        y, x = marker.location
        xy_flip = [ x - 0.5, h - y - 0.5]
        dst_pts.append(xy_flip)

    if return_text:
        # two decimal strings for textbox
        src_pts_string = 'src_pts = ' + ', '.join([f'[{y:.02f}, {x:.02f}]' for [y, x] in src_pts])
        dst_pts_string = 'dst_pts = ' + ', '.join([f'[{y:.02f}, {x:.02f}]' for [y, x] in dst_pts])

        pts_string = f'# corner points for image registration: \n{src_pts_string}\n{dst_pts_string}'

        return pts_string

    else:
        return src_pts, dst_pts



class ImageRegistrationHelper(object):

    def on_marker_move_(self, change):

            self.textbox.value = extract_corner_points(self.src_markers, self.src_shape,
                                                       self.dst_markers, self.dst_shape,
                                                       return_text=True)

    def get_corner_points_for_image_registration(self, verbose=True):
        '''Get 4 source and 4 destination corner points for image registration.

        Extracts current positions from all markers. Output can be used in warp function.

        Returns: src_points, dst_points
        '''

        src_points, dst_points = extract_corner_points(self.src_markers, self.src_shape,
                                           self.dst_markers, self.dst_shape,
                                           return_text=False)

        print(f'src_points = {src_points}\ndst_points = {dst_points}')

        src_points = np.array(src_points)
        dst_points = np.array(dst_points)

        return src_points, dst_points


    def __init__(self, src_imdata, dst_imdata):

        layout = Layout(width='500px', height='500px')
        resolutions = [256 * 2 ** (-l) for l in range(20)]

        crs = dict(name='Pixelcoords', custom=True, bounds=[[0, 0], [1000, 1000]], origin=[0, 0],
                    resolutions=resolutions, proj4def='+proj=longlat')


        # read images and convert to png/base64 url
        src_url, self.src_shape = img_to_url(src_imdata)
        dst_url, self.dst_shape = img_to_url(dst_imdata)


        src_h, src_w = self.src_shape
        self.src_map = Map(scroll_wheel_zoom=True, crs=crs, center=[src_h/2, src_w/2], zoom=4,
                      layout=layout, interpolation='nearest')

        dst_h, dst_w = self.dst_shape
        self.dst_map = Map(scroll_wheel_zoom=True, crs=crs, center=[dst_h/2, dst_w/2], zoom=4,
                      layout=layout, interpolation='nearest')

        self.src_markers = mark_corners(self.src_map, self.src_shape)
        self.dst_markers = mark_corners(self.dst_map, self.dst_shape)

        src_imo = ImageOverlay(url=src_url, bounds=[[0, 0], self.src_shape]) # SW and NE corners
        dst_imo = ImageOverlay(url=dst_url, bounds=[[0, 0], self.dst_shape]) # SW and NE corners

        self.src_map.add(src_imo)
        self.dst_map.add(dst_imo)

        # this hack removes the default world map layer
        # (seems I can do that only after creating other widgets)
        self.src_map.remove(self.src_map.layers[0])
        self.dst_map.remove(self.dst_map.layers[0])

        for marker in self.src_markers:
            marker.observe(self.on_marker_move_)

        for marker in self.dst_markers:
            marker.observe(self.on_marker_move_)

        # initialize textbox
        self.pts_string = extract_corner_points(self.src_markers, self.src_shape,
                                           self.dst_markers, self.dst_shape,
                                           return_text=True)

        self.textbox = ipywidgets.Textarea(self.pts_string, rows=3, layout=Layout(width='100%'))

        self.combi = VBox([HBox([self.src_map, self.dst_map]), self.textbox])

        display(self.combi)



def warp(im_src, im_dst, pts_src, pts_dst, keep_scale=True, rgba=True, alpha_color=[1, 0, 0]):
    '''Opencv based homographic registration. Can return transparent overlay (rgba).

    Returns: *im_warped*, *extent* '''

    src_h, src_w = im_src.shape[0:2]
    dst_h, dst_w = im_dst.shape[0:2]

    if keep_scale:
        scale = src_h / dst_h
    else:
        scale = 1

    # calculate homography
    hom, status = cv2.findHomography(pts_src, scale * pts_dst)

    # Size is nearest integer scaled (width,height) of im_dst
    size = round(scale * dst_w), round(scale * dst_h)

    # warp im_src onto destination
    im_warped = cv2.warpPerspective(im_src, hom, size)

    # warp white onto destination to create mask
    mask_src = np.ones([src_h, src_w])
    mask_warped = cv2.warpPerspective(mask_src, hom, size)

    # calculate extent for plotting
    h, w = im_dst.shape[0:2]
    extent =  (0, w, h, 0)

    # convert into rgba image
    if rgba is True:
        im_rgba = np.ones([h, w, 4])

        # for single channel image
        if len(im_src.shape) == 2:
            # colorize
            im_rgba[:,:,0:3] = alpha_color[0:3]
            #  make alpha layer
            im_rgba[:,:,3] = im_warped

        # otherwise assume image is rgb
        elif len(im_warped.shape) == 3:

            # rgb channels
            im_rgba[:,:,0:3] = im_warped[:,:,0:3]
            # alpha channels
            im_rgba[:,:,3] = mask_warped

        im_warped = im_rgba

    return im_warped, extent

