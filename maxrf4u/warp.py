# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/30_spatial-verus-spectral.ipynb (unless otherwise specified).

__all__ = ['warp']

# Cell

import numpy as np
import cv2


def warp(im_src, im_dst, pts_src, pts_dst, keep_scale=True, rgba=True, alpha_color=[1, 0, 0]):
    '''Opencv based homographic registration. Can return transparent overlay (rgba).

    Returns: *im_warped*, *extent* '''

    src_h, src_w = im_src.shape[0:2]
    dst_h, dst_w = im_dst.shape[0:2]

    if keep_scale:
        scale = src_h / dst_h
    else:
        scale = 1

    # calculate homography
    hom, status = cv2.findHomography(pts_src, scale * pts_dst)

    # Size is nearest integer scaled (width,height) of im_dst
    size = round(scale * dst_w), round(scale * dst_h)

    # warp im_src onto destination
    im_warped = cv2.warpPerspective(im_src, hom, size)

    # warp white onto destination to create mask
    mask_src = np.ones([src_h, src_w])
    mask_warped = cv2.warpPerspective(mask_src, hom, size)

    # calculate extent for plotting
    h, w = im_dst.shape[0:2]
    extent =  (0, w, h, 0)

    # convert into rgba image
    if rgba is True:
        im_rgba = np.ones([h, w, 4])

        # for single channel image
        if len(im_src.shape) == 2:
            # colorize
            im_rgba[:,:,0:3] = alpha_color[0:3]
            #  make alpha layer
            im_rgba[:,:,3] = im_warped

        # otherwise assume image is rgb
        elif len(im_warped.shape) == 3:

            # rgb channels
            im_rgba[:,:,0:3] = im_warped[:,:,0:3]
            # alpha channels
            im_rgba[:,:,3] = mask_warped

        im_warped = im_rgba

    return im_warped, extent