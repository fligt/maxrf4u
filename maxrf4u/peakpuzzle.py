# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/50_peak-pattern-puzzle.ipynb (unless otherwise specified).

__all__ = ['get_patterns', 'colorize', 'plot_ptrn', 'plot_patterns', 'plot_puzzle', 'all_elements', 'eoi']

# Cell

from maxrf4u import HotmaxAtlas
import re
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import mendeleev
import moseley as mos
import numpy as np


# all elements
all_elements = ['#H', '#He', '#Li', '#Be', '#B', '#C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al',
                'Si', 'P', 'S', 'Cl', '#Ar', 'K', 'Ca', '#Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe',
                'Co', 'Ni', 'Cu', 'Zn', '#Ga', '#Ge', 'As', '#Se', 'Br', '#Kr', '#Rb', 'Sr',
                '#Y', '#Zr', '#Nb', '#Mo', '#Tc', '#Ru', 'Rh', '#Pd', 'Ag', 'Cd', '#In', 'Sn',
                '#Sb', '#Te', 'I', '#Xe', '#Cs', 'Ba', '#La', '#Hf', '#Ta', '#W', '#Re', '#Os',
                '#Ir', '#Pt', '#Au', 'Hg', '#Tl', 'Pb', '#Bi', '#Po', '#At', '#Rn', '#Fr', '#Ra',
                '#Ac', '#Rf', '#Db', '#Sg', '#Bh', '#Hs', '#Mt', '#Ds', '#Rg', '#Cn', '#Nh',
                '#Fl', '#Mc', '#Lv', '#Ts', '#Og']

# elements of interest (to me)
eoi = [e for e in all_elements if not '#' in e]


def get_patterns(elements, tube_keV=30, eoi=None):
    '''Returns sorted pattern dict list, according to alpha peak energy. '''



    ptrn_dict_list = []

    for elem in elements:

        spectrum = mos.XFluo(elem, tube_keV=tube_keV, min_prom=0.01)

        peak_order = np.argsort(spectrum.peak_intensities)[::-1]

        alpha_keV = spectrum.peak_energies[peak_order][0]
        peaks_x = spectrum.peak_energies[peak_order]
        peaks_y = spectrum.peak_intensities[peak_order]

        peaks_xy = np.c_[peaks_x, peaks_y]

        alpha_escape_keV = alpha_keV - 1.74  # Silicon detector escape energy shift

        color = colorize(elem, eoi=eoi)

        name = mendeleev.element(elem).name

        ptrn_dict = {'elem': elem,
                     'name': name,
                     'peaks_xy': peaks_xy,
                     'alpha_escape_keV': alpha_escape_keV,
                     'color': color}

        ptrn_dict_list.append(ptrn_dict)

    # sort according to alpha energy
    alpha_keVs = [p['peaks_xy'][0, 0] for p in ptrn_dict_list]
    indices = np.argsort(alpha_keVs)

    ptrn_list = [ptrn_dict_list[i] for i in indices]

    return ptrn_list

def colorize(elem, eoi=None):
    '''Pick fixed color from nice color map for elements of interest. '''

    if eoi is None:

        # select elements of interest
        all_elements = ['#H', '#He', '#Li', '#Be', '#B', '#C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al',
                        'Si', 'P', 'S', 'Cl', '#Ar', 'K', 'Ca', '#Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe',
                        'Co', 'Ni', 'Cu', 'Zn', '#Ga', '#Ge', 'As', '#Se', 'Br', '#Kr', '#Rb', 'Sr',
                        '#Y', '#Zr', '#Nb', '#Mo', '#Tc', '#Ru', 'Rh', '#Pd', 'Ag', 'Cd', '#In', 'Sn',
                        '#Sb', '#Te', 'I', '#Xe', '#Cs', 'Ba', '#La', '#Hf', '#Ta', '#W', '#Re', '#Os',
                        '#Ir', '#Pt', '#Au', 'Hg', '#Tl', 'Pb', '#Bi', '#Po', '#At', '#Rn', '#Fr', '#Ra',
                        '#Ac', '#Rf', '#Db', '#Sg', '#Bh', '#Hs', '#Mt', '#Ds', '#Rg', '#Cn', '#Nh',
                        '#Fl', '#Mc', '#Lv', '#Ts', '#Og']

        eoi = [e for e in all_elements if not '#' in e]

    # tab20x2 color map
    tab20 = cm.tab20(np.arange(20))[:,0:3]
    colors = np.r_[tab20[::-1], tab20[::-1]**0.6]

    # this code logic is pretty ad hoc (needs improvement)
    # custom
    special_colors = {'Pb': (0.4, 0.4, 0.4),
                      'Cu': (0.1, 0.9, 0.3),
                      'Fe': (0.7, 0.5, 0.1),
                      'S': (1.0, 0.9, 0.1),
                      'Au': (1, 0.9, 0.1),
                      'Br': (0.4, 0.3, 0)}

    for e in special_colors.keys():
        if e in eoi:
            colors[eoi.index(e)] = special_colors[e]

    if elem in eoi:
            color = colors[eoi.index(elem)]

    else:
        color = [0, 0, 0]

    return color


def plot_ptrn(elem, y, ax, eoi=None, escape=True):
    '''Low level plot element pattern at level `y` in axes `ax`.'''

    ptrn = get_patterns([elem], eoi=eoi)[0]

    peaks_x, peaks_y = ptrn['peaks_xy'].T
    color = ptrn['color']

    alpha_escape_keV = ptrn['alpha_escape_keV']

    left_x = min(peaks_x)
    right_x = max(peaks_x)

    ones = np.ones_like(peaks_y)

    # if below spectrum rescale height y according to available space
    if y < 0:
        ymin = ax.get_ylim()[0]
        y = -(y / 5) * ymin

    ax.scatter(peaks_x, y * ones, s=15, color=color)
    ax.plot([left_x, right_x], [y, y], color=color, alpha=0.3)
    ax.scatter(peaks_x[0], y, marker='s', s=40, color=color)

    if escape is True:
        ax.scatter(alpha_escape_keV, y, marker='|', s=15, color=color)

    ax.annotate(ptrn['elem'], [right_x, y], xytext=[5, -1], fontsize=8, color=color,
                textcoords='offset points', ha='left', va='center')




    return ptrn


def plot_patterns(ptrn_list, ax=None, eoi=None, escape=True):
    '''Plot overview of element patterns `ptrn_list` in axes `ax`'''

    n_ptrns = len(ptrn_list)

    elements = [p['elem'] for p in ptrn_list]
    element_labels = [f'{mendeleev.element(e).name} ({e})' for e in elements]


    if ax is None:

        fig, ax = plt.subplots(figsize=[9, 8])#0.5*n_ptrns])

    for i, ptrn in enumerate(ptrn_list):

        plot_ptrn(ptrn['elem'], i, ax, eoi=eoi, escape=escape)

    ax.set_yticks(range(n_ptrns))
    ax.set_yticklabels(element_labels, fontsize=8)
    ax.set_ylim([-1, n_ptrns])

    plt.tight_layout()


def plot_puzzle(hma, n):

    fig, [ax0, ax1] = plt.subplots(nrows=2, sharex=True, figsize=[9, 9])

    ax0.set_yticks([])

    # pattern overview
    twax = ax0.twinx()
    eoi_ptrns = get_patterns(eoi)
    plot_patterns(eoi_ptrns, ax=twax)

    # vertical lines
    lines = hma.x_keVs[hma.peak_idxs_list[n]]
    ymin = twax.get_ylim()[0] #np.zeros_like(lines)
    ymax = twax.get_ylim()[1] #* np.ones_like(lines)

    twax.vlines(lines, ymin, ymax, alpha=0.3)

    # spectrum
    hma.plot_spectrum(n, footspace=0.5, ax=ax1, headspace=1)

    plt.subplots_adjust(hspace=0.05)

    return ax0, ax1
