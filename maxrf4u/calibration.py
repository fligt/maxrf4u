# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/20_calibration.ipynb (unless otherwise specified).

__all__ = ['calibrate', 'detector_angle', 'RHODIUM_Ka', 'IRON_Ka']

# Cell

#%%writefile /home/frank/Work/Projecten/DoRe/code/maxrf4u/calibration.py

# See development notebook: ~/Work/Projecten/DoRe/notebooks/2021-03-05-maxrf4u-dev.ipynb

import maxrf4u
import matplotlib.pyplot as plt
import numpy as np
import scipy.signal as ssg
import matplotlib.cm as cm
import math

RHODIUM_Ka = 20.210105052526263 # Rh_KL3
IRON_Ka = 6.4032016008004 # Fe_KL3

def calibrate(datastack_file, anode='Rh', prominence=0.1):
    '''Automatic two step energy energy calibration.

    In step 1 a preliminary calibration is done assuming that the
    sensor peak is located at 0 keV and the Rhodium anode Ka peak
    is next to it's high and broad Compton scattering peak in the sum spectrum.

    This preliminary calibration the enables the identification of Fe_Ka and a
    second precise calibration.'''

    assert anode == 'Rh', NotImplementedError('Sorry, need to implement other anode materials!')

    ds = maxrf4u.DataStack(datastack_file)

    y_max = ds.read(ds.MAXRF_MAXSPECTRUM)
    y_sum = ds.read(ds.MAXRF_SUMSPECTRUM)

    # find sensor and anode peaks in sum spectrum
    n_channels = len(y_sum)
    x_indices = np.arange(n_channels)
    sum_peak_indices, shapes_dict = ssg.find_peaks(y_sum, prominence=prominence)
    max_peak_indices, shapes_dict = ssg.find_peaks(y_max, prominence=prominence)
    peaks_y = y_sum[sum_peak_indices]

    # STEP 1: PRELIMINARY SENSOR + ANODE CALIBRATION TO LOCATE IRON Fe_Ka PEAK

    # clean spectrum by removing (typically highest) sensor peak
    n_sensor = n_channels // 20
    y_sum_clean = y_sum.copy()
    y_sum_clean[0:n_sensor] = 0

    # Now assume highest peak in clean spectrum
    # is Compton scattering of anode Ka emission
    compton_i = np.argmax(y_sum_clean)

    # find anode peak channel index right next to Compton peak
    right_peak_i = sum_peak_indices[list(sum_peak_indices).index(compton_i) + 1]
    right_keV = RHODIUM_Ka

    # assume sensor peak energy is zero
    left_peak_i = sum_peak_indices[0]
    left_keV = 0

    # determine sensor + anode based preliminary calibration
    slope = (right_keV - left_keV) / (right_peak_i - left_peak_i)
    offset = left_keV - slope * left_peak_i
    keVs_precalib = slope * x_indices + offset

    # STEP 2: PRECISE IRON Ka + ANODE CALIBRATION
    peak_keVs_precalib = keVs_precalib[max_peak_indices]

    # now find index of peak nearest to Fe_Ka energy
    iron_peak_i = np.argmin((peak_keVs_precalib - IRON_Ka)**2)

    # calibrate again now with iron Ka left hand peak

    left_peak_i = max_peak_indices[iron_peak_i]
    left_keV = IRON_Ka

    slope = (right_keV - left_keV) / (right_peak_i - left_peak_i)
    offset = left_keV - slope * left_peak_i
    x_keVs = slope * x_indices + offset

    # Calibration peak diagnostics
    iron_xy = x_keVs[left_peak_i], y_max[left_peak_i]
    compton_xy = x_keVs[compton_i], y_sum[compton_i]
    anode_xy = x_keVs[right_peak_i], y_sum[right_peak_i]

    theta = detector_angle(compton_xy[0], anode_xy[0])

    calib_peaks_x, calib_peaks_y = np.array([iron_xy, compton_xy, anode_xy]).T

    # Create calibration plot
    plt.ion()

    colors =  cm.tab10([0, 1, 2])
    fig, ax = plt.subplots(ncols=1, nrows=1, figsize=[7, 4])
    ax2 = ax.twinx()
    line1, = ax.plot(x_keVs, y_max, label='max spectrum', color='green')
    line2, = ax2.plot(x_keVs, y_sum, label='sum spectrum', color='blue')


    # annotate iron in max spectrum
    ax.axvline(iron_xy[0], linestyle=':', color='r')
    ax.annotate(f'Iron Ka \n({iron_xy[0]:.3f} keV)', iron_xy, xytext=[20, -20],
                textcoords='offset points', ha='left',
                arrowprops=dict(arrowstyle="->", facecolor='grey'))
    ax.scatter(*iron_xy, s=40, facecolor=[1, 0.5, 0.5], edgecolor='green', zorder=10)

    ax.set_title('Energy Calibration')
    ax.set_xlabel('Energy [keV]')
    ax.set_ylabel('Max Spectrum Intensity [counts]')


    # annotate compton peak in sum spectrum
    ax2.annotate('Compton Peak\n(inelastic scattering)\n' +
                r'$\theta$' + f'={int(theta)}' + r'$^{\circ}$',
                compton_xy, xytext=[20, 20],
                textcoords='offset points', ha='left',
                arrowprops=dict(arrowstyle="->", facecolor='grey'))
    ax2.scatter(*compton_xy, s=40, facecolor='white', edgecolor='blue', zorder=10)

    # annotate anode peak in sum spectrum
    ax2.axvline(anode_xy[0], linestyle=':', color='r')
    ax2.annotate(f'Anode\nRhodium Ka \n({anode_xy[0]:.2f} keV)', anode_xy, xytext=[20, 20],
                textcoords='offset points', ha='left',
                arrowprops=dict(arrowstyle="->", facecolor='grey'))
    ax2.scatter(*anode_xy, s=40, facecolor=[1, 0.5, 0.5], edgecolor=[0, 0, 1], zorder=10)

    ax2.set_ylabel('Sum Spectrum Intensity [counts]')

    ax.legend(handles=[line1, line2], loc='upper right')


    # force updating plot
    plt.pause(0.2)
    fig.canvas.draw()

    # write energies
    write = input('Write energy calibration to datastack file [y/n]? ')

    if write == 'y':
        print(f'\nWriting channel energies (keV) to: {datastack_file}')
        maxrf4u.append(x_keVs, ds.MAXRF_ENERGIES, ds.datastack_file)

    return x_keVs


def detector_angle(keV0, keV1):
    '''Calculate detector angle *theta* (degrees)

    from Compton peak energy *keV0* and anode energy *keV1* and . '''

    assert keV0 < keV1, 'Compton energy should be less then anode energy'

    # constants
    e = 1.602e-19 # electron charge
    pi = math.pi
    h = 6.62607e-34 # Planck constant
    m0 = 9.10939e-31 # electron mass
    c = 2.998e8 # speed of light


    # convert keV to Joule
    E0 = 1000 * keV0 * e
    E1 = 1000 * keV1 * e

    theta = (180 / pi) * np.arccos(1 - m0 * c**2 * (1/E0 - 1/E1))

    return theta